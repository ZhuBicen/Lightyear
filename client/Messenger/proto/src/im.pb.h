// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_im_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_im_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 30010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 30010000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "core.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_im_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_im_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace im {
class AlertMessage;
class AlertMessageDefaultTypeInternal;
extern AlertMessageDefaultTypeInternal _AlertMessage_default_instance_;
class ChatMessage;
class ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class MessageElement;
class MessageElementDefaultTypeInternal;
extern MessageElementDefaultTypeInternal _MessageElement_default_instance_;
class Presence;
class PresenceDefaultTypeInternal;
extern PresenceDefaultTypeInternal _Presence_default_instance_;
class PresenceReq;
class PresenceReqDefaultTypeInternal;
extern PresenceReqDefaultTypeInternal _PresenceReq_default_instance_;
class PresenceResp;
class PresenceRespDefaultTypeInternal;
extern PresenceRespDefaultTypeInternal _PresenceResp_default_instance_;
class RosterItem;
class RosterItemDefaultTypeInternal;
extern RosterItemDefaultTypeInternal _RosterItem_default_instance_;
class RosterReq;
class RosterReqDefaultTypeInternal;
extern RosterReqDefaultTypeInternal _RosterReq_default_instance_;
class RosterResp;
class RosterRespDefaultTypeInternal;
extern RosterRespDefaultTypeInternal _RosterResp_default_instance_;
}  // namespace im
PROTOBUF_NAMESPACE_OPEN
template<> ::im::AlertMessage* Arena::CreateMaybeMessage<::im::AlertMessage>(Arena*);
template<> ::im::ChatMessage* Arena::CreateMaybeMessage<::im::ChatMessage>(Arena*);
template<> ::im::MessageElement* Arena::CreateMaybeMessage<::im::MessageElement>(Arena*);
template<> ::im::Presence* Arena::CreateMaybeMessage<::im::Presence>(Arena*);
template<> ::im::PresenceReq* Arena::CreateMaybeMessage<::im::PresenceReq>(Arena*);
template<> ::im::PresenceResp* Arena::CreateMaybeMessage<::im::PresenceResp>(Arena*);
template<> ::im::RosterItem* Arena::CreateMaybeMessage<::im::RosterItem>(Arena*);
template<> ::im::RosterReq* Arena::CreateMaybeMessage<::im::RosterReq>(Arena*);
template<> ::im::RosterResp* Arena::CreateMaybeMessage<::im::RosterResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace im {

enum Presence_Show : int {
  Presence_Show_ONLINE = 0,
  Presence_Show_OFFLINE = 1,
  Presence_Show_AWAY = 2
};
bool Presence_Show_IsValid(int value);
constexpr Presence_Show Presence_Show_Show_MIN = Presence_Show_ONLINE;
constexpr Presence_Show Presence_Show_Show_MAX = Presence_Show_AWAY;
constexpr int Presence_Show_Show_ARRAYSIZE = Presence_Show_Show_MAX + 1;

const std::string& Presence_Show_Name(Presence_Show value);
template<typename T>
inline const std::string& Presence_Show_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Presence_Show>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Presence_Show_Name.");
  return Presence_Show_Name(static_cast<Presence_Show>(enum_t_value));
}
bool Presence_Show_Parse(
    const std::string& name, Presence_Show* value);
enum EnumMessageElement : int {
  TEXT = 0,
  SMILEY = 1,
  BITMAP = 2
};
bool EnumMessageElement_IsValid(int value);
constexpr EnumMessageElement EnumMessageElement_MIN = TEXT;
constexpr EnumMessageElement EnumMessageElement_MAX = BITMAP;
constexpr int EnumMessageElement_ARRAYSIZE = EnumMessageElement_MAX + 1;

const std::string& EnumMessageElement_Name(EnumMessageElement value);
template<typename T>
inline const std::string& EnumMessageElement_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnumMessageElement>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnumMessageElement_Name.");
  return EnumMessageElement_Name(static_cast<EnumMessageElement>(enum_t_value));
}
bool EnumMessageElement_Parse(
    const std::string& name, EnumMessageElement* value);
// ===================================================================

class Presence :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.Presence) */ {
 public:
  Presence();
  virtual ~Presence();

  Presence(const Presence& from);
  Presence(Presence&& from) noexcept
    : Presence() {
    *this = ::std::move(from);
  }

  inline Presence& operator=(const Presence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Presence& operator=(Presence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Presence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Presence* internal_default_instance() {
    return reinterpret_cast<const Presence*>(
               &_Presence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Presence& a, Presence& b) {
    a.Swap(&b);
  }
  inline void Swap(Presence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Presence* New() const final {
    return CreateMaybeMessage<Presence>(nullptr);
  }

  Presence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Presence>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Presence& from);
  void MergeFrom(const Presence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Presence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.Presence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Presence_Show Show;
  static constexpr Show ONLINE =
    Presence_Show_ONLINE;
  static constexpr Show OFFLINE =
    Presence_Show_OFFLINE;
  static constexpr Show AWAY =
    Presence_Show_AWAY;
  static inline bool Show_IsValid(int value) {
    return Presence_Show_IsValid(value);
  }
  static constexpr Show Show_MIN =
    Presence_Show_Show_MIN;
  static constexpr Show Show_MAX =
    Presence_Show_Show_MAX;
  static constexpr int Show_ARRAYSIZE =
    Presence_Show_Show_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Show_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Show>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Show_Name.");
    return Presence_Show_Name(enum_t_value);
  }
  static inline bool Show_Parse(const std::string& name,
      Show* value) {
    return Presence_Show_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 6,
    kFromJidFieldNumber = 1,
    kToJidFieldNumber = 2,
    kPriorityFieldNumber = 4,
    kShowFieldNumber = 5,
  };
  // optional string status = 6;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional .core.Jid fromJid = 1;
  bool has_fromjid() const;
  private:
  bool _internal_has_fromjid() const;
  public:
  void clear_fromjid();
  const ::core::Jid& fromjid() const;
  ::core::Jid* release_fromjid();
  ::core::Jid* mutable_fromjid();
  void set_allocated_fromjid(::core::Jid* fromjid);
  private:
  const ::core::Jid& _internal_fromjid() const;
  ::core::Jid* _internal_mutable_fromjid();
  public:

  // optional .core.Jid toJid = 2;
  bool has_tojid() const;
  private:
  bool _internal_has_tojid() const;
  public:
  void clear_tojid();
  const ::core::Jid& tojid() const;
  ::core::Jid* release_tojid();
  ::core::Jid* mutable_tojid();
  void set_allocated_tojid(::core::Jid* tojid);
  private:
  const ::core::Jid& _internal_tojid() const;
  ::core::Jid* _internal_mutable_tojid();
  public:

  // optional int32 priority = 4;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::int32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .im.Presence.Show show = 5;
  bool has_show() const;
  private:
  bool _internal_has_show() const;
  public:
  void clear_show();
  ::im::Presence_Show show() const;
  void set_show(::im::Presence_Show value);
  private:
  ::im::Presence_Show _internal_show() const;
  void _internal_set_show(::im::Presence_Show value);
  public:

  // @@protoc_insertion_point(class_scope:im.Presence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::core::Jid* fromjid_;
  ::core::Jid* tojid_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_;
  int show_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class RosterReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.RosterReq) */ {
 public:
  RosterReq();
  virtual ~RosterReq();

  RosterReq(const RosterReq& from);
  RosterReq(RosterReq&& from) noexcept
    : RosterReq() {
    *this = ::std::move(from);
  }

  inline RosterReq& operator=(const RosterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosterReq& operator=(RosterReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RosterReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RosterReq* internal_default_instance() {
    return reinterpret_cast<const RosterReq*>(
               &_RosterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RosterReq& a, RosterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RosterReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RosterReq* New() const final {
    return CreateMaybeMessage<RosterReq>(nullptr);
  }

  RosterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RosterReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RosterReq& from);
  void MergeFrom(const RosterReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RosterReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.RosterReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJidFieldNumber = 1,
  };
  // required .core.Jid jid = 1;
  bool has_jid() const;
  private:
  bool _internal_has_jid() const;
  public:
  void clear_jid();
  const ::core::Jid& jid() const;
  ::core::Jid* release_jid();
  ::core::Jid* mutable_jid();
  void set_allocated_jid(::core::Jid* jid);
  private:
  const ::core::Jid& _internal_jid() const;
  ::core::Jid* _internal_mutable_jid();
  public:

  // @@protoc_insertion_point(class_scope:im.RosterReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::core::Jid* jid_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class RosterItem :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.RosterItem) */ {
 public:
  RosterItem();
  virtual ~RosterItem();

  RosterItem(const RosterItem& from);
  RosterItem(RosterItem&& from) noexcept
    : RosterItem() {
    *this = ::std::move(from);
  }

  inline RosterItem& operator=(const RosterItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosterItem& operator=(RosterItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RosterItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RosterItem* internal_default_instance() {
    return reinterpret_cast<const RosterItem*>(
               &_RosterItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RosterItem& a, RosterItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RosterItem* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RosterItem* New() const final {
    return CreateMaybeMessage<RosterItem>(nullptr);
  }

  RosterItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RosterItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RosterItem& from);
  void MergeFrom(const RosterItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RosterItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.RosterItem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupTagFieldNumber = 8,
    kNameFieldNumber = 3,
    kNicknameFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kPositionFieldNumber = 6,
    kDepartmentFieldNumber = 7,
    kJidFieldNumber = 1,
    kOnlineStatusFieldNumber = 2,
  };
  // repeated string groupTag = 8;
  int grouptag_size() const;
  private:
  int _internal_grouptag_size() const;
  public:
  void clear_grouptag();
  const std::string& grouptag(int index) const;
  std::string* mutable_grouptag(int index);
  void set_grouptag(int index, const std::string& value);
  void set_grouptag(int index, std::string&& value);
  void set_grouptag(int index, const char* value);
  void set_grouptag(int index, const char* value, size_t size);
  std::string* add_grouptag();
  void add_grouptag(const std::string& value);
  void add_grouptag(std::string&& value);
  void add_grouptag(const char* value);
  void add_grouptag(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& grouptag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_grouptag();
  private:
  const std::string& _internal_grouptag(int index) const;
  std::string* _internal_add_grouptag();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string nickname = 4;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  void set_nickname(const std::string& value);
  void set_nickname(std::string&& value);
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  std::string* mutable_nickname();
  std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string position = 6;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const std::string& position() const;
  void set_position(const std::string& value);
  void set_position(std::string&& value);
  void set_position(const char* value);
  void set_position(const char* value, size_t size);
  std::string* mutable_position();
  std::string* release_position();
  void set_allocated_position(std::string* position);
  private:
  const std::string& _internal_position() const;
  void _internal_set_position(const std::string& value);
  std::string* _internal_mutable_position();
  public:

  // optional string department = 7;
  bool has_department() const;
  private:
  bool _internal_has_department() const;
  public:
  void clear_department();
  const std::string& department() const;
  void set_department(const std::string& value);
  void set_department(std::string&& value);
  void set_department(const char* value);
  void set_department(const char* value, size_t size);
  std::string* mutable_department();
  std::string* release_department();
  void set_allocated_department(std::string* department);
  private:
  const std::string& _internal_department() const;
  void _internal_set_department(const std::string& value);
  std::string* _internal_mutable_department();
  public:

  // required .core.Jid jid = 1;
  bool has_jid() const;
  private:
  bool _internal_has_jid() const;
  public:
  void clear_jid();
  const ::core::Jid& jid() const;
  ::core::Jid* release_jid();
  ::core::Jid* mutable_jid();
  void set_allocated_jid(::core::Jid* jid);
  private:
  const ::core::Jid& _internal_jid() const;
  ::core::Jid* _internal_mutable_jid();
  public:

  // required int32 onlineStatus = 2;
  bool has_onlinestatus() const;
  private:
  bool _internal_has_onlinestatus() const;
  public:
  void clear_onlinestatus();
  ::PROTOBUF_NAMESPACE_ID::int32 onlinestatus() const;
  void set_onlinestatus(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_onlinestatus() const;
  void _internal_set_onlinestatus(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:im.RosterItem)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> grouptag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr department_;
  ::core::Jid* jid_;
  ::PROTOBUF_NAMESPACE_ID::int32 onlinestatus_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class RosterResp :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.RosterResp) */ {
 public:
  RosterResp();
  virtual ~RosterResp();

  RosterResp(const RosterResp& from);
  RosterResp(RosterResp&& from) noexcept
    : RosterResp() {
    *this = ::std::move(from);
  }

  inline RosterResp& operator=(const RosterResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosterResp& operator=(RosterResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RosterResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RosterResp* internal_default_instance() {
    return reinterpret_cast<const RosterResp*>(
               &_RosterResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RosterResp& a, RosterResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RosterResp* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RosterResp* New() const final {
    return CreateMaybeMessage<RosterResp>(nullptr);
  }

  RosterResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RosterResp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RosterResp& from);
  void MergeFrom(const RosterResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RosterResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.RosterResp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRosterItemsFieldNumber = 1,
  };
  // repeated .im.RosterItem rosterItems = 1;
  int rosteritems_size() const;
  private:
  int _internal_rosteritems_size() const;
  public:
  void clear_rosteritems();
  ::im::RosterItem* mutable_rosteritems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::RosterItem >*
      mutable_rosteritems();
  private:
  const ::im::RosterItem& _internal_rosteritems(int index) const;
  ::im::RosterItem* _internal_add_rosteritems();
  public:
  const ::im::RosterItem& rosteritems(int index) const;
  ::im::RosterItem* add_rosteritems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::RosterItem >&
      rosteritems() const;

  // @@protoc_insertion_point(class_scope:im.RosterResp)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::RosterItem > rosteritems_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class PresenceReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.PresenceReq) */ {
 public:
  PresenceReq();
  virtual ~PresenceReq();

  PresenceReq(const PresenceReq& from);
  PresenceReq(PresenceReq&& from) noexcept
    : PresenceReq() {
    *this = ::std::move(from);
  }

  inline PresenceReq& operator=(const PresenceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresenceReq& operator=(PresenceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PresenceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PresenceReq* internal_default_instance() {
    return reinterpret_cast<const PresenceReq*>(
               &_PresenceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PresenceReq& a, PresenceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PresenceReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PresenceReq* New() const final {
    return CreateMaybeMessage<PresenceReq>(nullptr);
  }

  PresenceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PresenceReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PresenceReq& from);
  void MergeFrom(const PresenceReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PresenceReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.PresenceReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJidFieldNumber = 1,
  };
  // required .core.Jid jid = 1;
  bool has_jid() const;
  private:
  bool _internal_has_jid() const;
  public:
  void clear_jid();
  const ::core::Jid& jid() const;
  ::core::Jid* release_jid();
  ::core::Jid* mutable_jid();
  void set_allocated_jid(::core::Jid* jid);
  private:
  const ::core::Jid& _internal_jid() const;
  ::core::Jid* _internal_mutable_jid();
  public:

  // @@protoc_insertion_point(class_scope:im.PresenceReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::core::Jid* jid_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class PresenceResp :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.PresenceResp) */ {
 public:
  PresenceResp();
  virtual ~PresenceResp();

  PresenceResp(const PresenceResp& from);
  PresenceResp(PresenceResp&& from) noexcept
    : PresenceResp() {
    *this = ::std::move(from);
  }

  inline PresenceResp& operator=(const PresenceResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresenceResp& operator=(PresenceResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PresenceResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PresenceResp* internal_default_instance() {
    return reinterpret_cast<const PresenceResp*>(
               &_PresenceResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PresenceResp& a, PresenceResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PresenceResp* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PresenceResp* New() const final {
    return CreateMaybeMessage<PresenceResp>(nullptr);
  }

  PresenceResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PresenceResp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PresenceResp& from);
  void MergeFrom(const PresenceResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PresenceResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.PresenceResp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJidsFieldNumber = 1,
  };
  // repeated .core.Jid jids = 1;
  int jids_size() const;
  private:
  int _internal_jids_size() const;
  public:
  void clear_jids();
  ::core::Jid* mutable_jids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::core::Jid >*
      mutable_jids();
  private:
  const ::core::Jid& _internal_jids(int index) const;
  ::core::Jid* _internal_add_jids();
  public:
  const ::core::Jid& jids(int index) const;
  ::core::Jid* add_jids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::core::Jid >&
      jids() const;

  // @@protoc_insertion_point(class_scope:im.PresenceResp)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::core::Jid > jids_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class MessageElement :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.MessageElement) */ {
 public:
  MessageElement();
  virtual ~MessageElement();

  MessageElement(const MessageElement& from);
  MessageElement(MessageElement&& from) noexcept
    : MessageElement() {
    *this = ::std::move(from);
  }

  inline MessageElement& operator=(const MessageElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageElement& operator=(MessageElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MessageElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageElement* internal_default_instance() {
    return reinterpret_cast<const MessageElement*>(
               &_MessageElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageElement& a, MessageElement& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageElement* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageElement* New() const final {
    return CreateMaybeMessage<MessageElement>(nullptr);
  }

  MessageElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageElement>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MessageElement& from);
  void MergeFrom(const MessageElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageElement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.MessageElement";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // required bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required .im.EnumMessageElement kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::im::EnumMessageElement kind() const;
  void set_kind(::im::EnumMessageElement value);
  private:
  ::im::EnumMessageElement _internal_kind() const;
  void _internal_set_kind(::im::EnumMessageElement value);
  public:

  // @@protoc_insertion_point(class_scope:im.MessageElement)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int kind_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.ChatMessage) */ {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const final {
    return CreateMaybeMessage<ChatMessage>(nullptr);
  }

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.ChatMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 3,
    kFromJidFieldNumber = 1,
    kToJidFieldNumber = 2,
  };
  // repeated .im.MessageElement body = 3;
  int body_size() const;
  private:
  int _internal_body_size() const;
  public:
  void clear_body();
  ::im::MessageElement* mutable_body(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::MessageElement >*
      mutable_body();
  private:
  const ::im::MessageElement& _internal_body(int index) const;
  ::im::MessageElement* _internal_add_body();
  public:
  const ::im::MessageElement& body(int index) const;
  ::im::MessageElement* add_body();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::MessageElement >&
      body() const;

  // required .core.Jid fromJid = 1;
  bool has_fromjid() const;
  private:
  bool _internal_has_fromjid() const;
  public:
  void clear_fromjid();
  const ::core::Jid& fromjid() const;
  ::core::Jid* release_fromjid();
  ::core::Jid* mutable_fromjid();
  void set_allocated_fromjid(::core::Jid* fromjid);
  private:
  const ::core::Jid& _internal_fromjid() const;
  ::core::Jid* _internal_mutable_fromjid();
  public:

  // required .core.Jid toJid = 2;
  bool has_tojid() const;
  private:
  bool _internal_has_tojid() const;
  public:
  void clear_tojid();
  const ::core::Jid& tojid() const;
  ::core::Jid* release_tojid();
  ::core::Jid* mutable_tojid();
  void set_allocated_tojid(::core::Jid* tojid);
  private:
  const ::core::Jid& _internal_tojid() const;
  ::core::Jid* _internal_mutable_tojid();
  public:

  // @@protoc_insertion_point(class_scope:im.ChatMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::MessageElement > body_;
  ::core::Jid* fromjid_;
  ::core::Jid* tojid_;
  friend struct ::TableStruct_im_2eproto;
};
// -------------------------------------------------------------------

class AlertMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:im.AlertMessage) */ {
 public:
  AlertMessage();
  virtual ~AlertMessage();

  AlertMessage(const AlertMessage& from);
  AlertMessage(AlertMessage&& from) noexcept
    : AlertMessage() {
    *this = ::std::move(from);
  }

  inline AlertMessage& operator=(const AlertMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlertMessage& operator=(AlertMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AlertMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AlertMessage* internal_default_instance() {
    return reinterpret_cast<const AlertMessage*>(
               &_AlertMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AlertMessage& a, AlertMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AlertMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AlertMessage* New() const final {
    return CreateMaybeMessage<AlertMessage>(nullptr);
  }

  AlertMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AlertMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AlertMessage& from);
  void MergeFrom(const AlertMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AlertMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "im.AlertMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 3,
  };
  // required string body = 3;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  void set_body(const std::string& value);
  void set_body(std::string&& value);
  void set_body(const char* value);
  void set_body(const char* value, size_t size);
  std::string* mutable_body();
  std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:im.AlertMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  friend struct ::TableStruct_im_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Presence

// optional .core.Jid fromJid = 1;
inline bool Presence::_internal_has_fromjid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || fromjid_ != nullptr);
  return value;
}
inline bool Presence::has_fromjid() const {
  return _internal_has_fromjid();
}
inline const ::core::Jid& Presence::_internal_fromjid() const {
  const ::core::Jid* p = fromjid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& Presence::fromjid() const {
  // @@protoc_insertion_point(field_get:im.Presence.fromJid)
  return _internal_fromjid();
}
inline ::core::Jid* Presence::release_fromjid() {
  // @@protoc_insertion_point(field_release:im.Presence.fromJid)
  _has_bits_[0] &= ~0x00000002u;
  ::core::Jid* temp = fromjid_;
  fromjid_ = nullptr;
  return temp;
}
inline ::core::Jid* Presence::_internal_mutable_fromjid() {
  _has_bits_[0] |= 0x00000002u;
  if (fromjid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    fromjid_ = p;
  }
  return fromjid_;
}
inline ::core::Jid* Presence::mutable_fromjid() {
  // @@protoc_insertion_point(field_mutable:im.Presence.fromJid)
  return _internal_mutable_fromjid();
}
inline void Presence::set_allocated_fromjid(::core::Jid* fromjid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fromjid_);
  }
  if (fromjid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fromjid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fromjid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fromjid_ = fromjid;
  // @@protoc_insertion_point(field_set_allocated:im.Presence.fromJid)
}

// optional .core.Jid toJid = 2;
inline bool Presence::_internal_has_tojid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || tojid_ != nullptr);
  return value;
}
inline bool Presence::has_tojid() const {
  return _internal_has_tojid();
}
inline const ::core::Jid& Presence::_internal_tojid() const {
  const ::core::Jid* p = tojid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& Presence::tojid() const {
  // @@protoc_insertion_point(field_get:im.Presence.toJid)
  return _internal_tojid();
}
inline ::core::Jid* Presence::release_tojid() {
  // @@protoc_insertion_point(field_release:im.Presence.toJid)
  _has_bits_[0] &= ~0x00000004u;
  ::core::Jid* temp = tojid_;
  tojid_ = nullptr;
  return temp;
}
inline ::core::Jid* Presence::_internal_mutable_tojid() {
  _has_bits_[0] |= 0x00000004u;
  if (tojid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    tojid_ = p;
  }
  return tojid_;
}
inline ::core::Jid* Presence::mutable_tojid() {
  // @@protoc_insertion_point(field_mutable:im.Presence.toJid)
  return _internal_mutable_tojid();
}
inline void Presence::set_allocated_tojid(::core::Jid* tojid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tojid_);
  }
  if (tojid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tojid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tojid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tojid_ = tojid;
  // @@protoc_insertion_point(field_set_allocated:im.Presence.toJid)
}

// optional int32 priority = 4;
inline bool Presence::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Presence::has_priority() const {
  return _internal_has_priority();
}
inline void Presence::clear_priority() {
  priority_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Presence::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Presence::priority() const {
  // @@protoc_insertion_point(field_get:im.Presence.priority)
  return _internal_priority();
}
inline void Presence::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  priority_ = value;
}
inline void Presence::set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:im.Presence.priority)
}

// optional .im.Presence.Show show = 5;
inline bool Presence::_internal_has_show() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Presence::has_show() const {
  return _internal_has_show();
}
inline void Presence::clear_show() {
  show_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::im::Presence_Show Presence::_internal_show() const {
  return static_cast< ::im::Presence_Show >(show_);
}
inline ::im::Presence_Show Presence::show() const {
  // @@protoc_insertion_point(field_get:im.Presence.show)
  return _internal_show();
}
inline void Presence::_internal_set_show(::im::Presence_Show value) {
  assert(::im::Presence_Show_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  show_ = value;
}
inline void Presence::set_show(::im::Presence_Show value) {
  _internal_set_show(value);
  // @@protoc_insertion_point(field_set:im.Presence.show)
}

// optional string status = 6;
inline bool Presence::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Presence::has_status() const {
  return _internal_has_status();
}
inline void Presence::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Presence::status() const {
  // @@protoc_insertion_point(field_get:im.Presence.status)
  return _internal_status();
}
inline void Presence::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:im.Presence.status)
}
inline std::string* Presence::mutable_status() {
  // @@protoc_insertion_point(field_mutable:im.Presence.status)
  return _internal_mutable_status();
}
inline const std::string& Presence::_internal_status() const {
  return status_.GetNoArena();
}
inline void Presence::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Presence::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.Presence.status)
}
inline void Presence::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.Presence.status)
}
inline void Presence::set_status(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.Presence.status)
}
inline std::string* Presence::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Presence::release_status() {
  // @@protoc_insertion_point(field_release:im.Presence.status)
  if (!has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Presence::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:im.Presence.status)
}

// -------------------------------------------------------------------

// RosterReq

// required .core.Jid jid = 1;
inline bool RosterReq::_internal_has_jid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || jid_ != nullptr);
  return value;
}
inline bool RosterReq::has_jid() const {
  return _internal_has_jid();
}
inline const ::core::Jid& RosterReq::_internal_jid() const {
  const ::core::Jid* p = jid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& RosterReq::jid() const {
  // @@protoc_insertion_point(field_get:im.RosterReq.jid)
  return _internal_jid();
}
inline ::core::Jid* RosterReq::release_jid() {
  // @@protoc_insertion_point(field_release:im.RosterReq.jid)
  _has_bits_[0] &= ~0x00000001u;
  ::core::Jid* temp = jid_;
  jid_ = nullptr;
  return temp;
}
inline ::core::Jid* RosterReq::_internal_mutable_jid() {
  _has_bits_[0] |= 0x00000001u;
  if (jid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    jid_ = p;
  }
  return jid_;
}
inline ::core::Jid* RosterReq::mutable_jid() {
  // @@protoc_insertion_point(field_mutable:im.RosterReq.jid)
  return _internal_mutable_jid();
}
inline void RosterReq::set_allocated_jid(::core::Jid* jid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(jid_);
  }
  if (jid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      jid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:im.RosterReq.jid)
}

// -------------------------------------------------------------------

// RosterItem

// required .core.Jid jid = 1;
inline bool RosterItem::_internal_has_jid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || jid_ != nullptr);
  return value;
}
inline bool RosterItem::has_jid() const {
  return _internal_has_jid();
}
inline const ::core::Jid& RosterItem::_internal_jid() const {
  const ::core::Jid* p = jid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& RosterItem::jid() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.jid)
  return _internal_jid();
}
inline ::core::Jid* RosterItem::release_jid() {
  // @@protoc_insertion_point(field_release:im.RosterItem.jid)
  _has_bits_[0] &= ~0x00000020u;
  ::core::Jid* temp = jid_;
  jid_ = nullptr;
  return temp;
}
inline ::core::Jid* RosterItem::_internal_mutable_jid() {
  _has_bits_[0] |= 0x00000020u;
  if (jid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    jid_ = p;
  }
  return jid_;
}
inline ::core::Jid* RosterItem::mutable_jid() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.jid)
  return _internal_mutable_jid();
}
inline void RosterItem::set_allocated_jid(::core::Jid* jid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(jid_);
  }
  if (jid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      jid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.jid)
}

// required int32 onlineStatus = 2;
inline bool RosterItem::_internal_has_onlinestatus() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RosterItem::has_onlinestatus() const {
  return _internal_has_onlinestatus();
}
inline void RosterItem::clear_onlinestatus() {
  onlinestatus_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RosterItem::_internal_onlinestatus() const {
  return onlinestatus_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RosterItem::onlinestatus() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.onlineStatus)
  return _internal_onlinestatus();
}
inline void RosterItem::_internal_set_onlinestatus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  onlinestatus_ = value;
}
inline void RosterItem::set_onlinestatus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_onlinestatus(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.onlineStatus)
}

// optional string name = 3;
inline bool RosterItem::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RosterItem::has_name() const {
  return _internal_has_name();
}
inline void RosterItem::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RosterItem::name() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.name)
  return _internal_name();
}
inline void RosterItem::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.name)
}
inline std::string* RosterItem::mutable_name() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.name)
  return _internal_mutable_name();
}
inline const std::string& RosterItem::_internal_name() const {
  return name_.GetNoArena();
}
inline void RosterItem::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RosterItem::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.RosterItem.name)
}
inline void RosterItem::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.RosterItem.name)
}
inline void RosterItem::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.name)
}
inline std::string* RosterItem::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RosterItem::release_name() {
  // @@protoc_insertion_point(field_release:im.RosterItem.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RosterItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.name)
}

// optional string nickname = 4;
inline bool RosterItem::_internal_has_nickname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RosterItem::has_nickname() const {
  return _internal_has_nickname();
}
inline void RosterItem::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RosterItem::nickname() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.nickname)
  return _internal_nickname();
}
inline void RosterItem::set_nickname(const std::string& value) {
  _internal_set_nickname(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.nickname)
}
inline std::string* RosterItem::mutable_nickname() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.nickname)
  return _internal_mutable_nickname();
}
inline const std::string& RosterItem::_internal_nickname() const {
  return nickname_.GetNoArena();
}
inline void RosterItem::_internal_set_nickname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nickname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RosterItem::set_nickname(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nickname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.RosterItem.nickname)
}
inline void RosterItem::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nickname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.RosterItem.nickname)
}
inline void RosterItem::set_nickname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nickname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.nickname)
}
inline std::string* RosterItem::_internal_mutable_nickname() {
  _has_bits_[0] |= 0x00000002u;
  return nickname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RosterItem::release_nickname() {
  // @@protoc_insertion_point(field_release:im.RosterItem.nickname)
  if (!has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nickname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RosterItem::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nickname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.nickname)
}

// optional string description = 5;
inline bool RosterItem::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RosterItem::has_description() const {
  return _internal_has_description();
}
inline void RosterItem::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RosterItem::description() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.description)
  return _internal_description();
}
inline void RosterItem::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.description)
}
inline std::string* RosterItem::mutable_description() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.description)
  return _internal_mutable_description();
}
inline const std::string& RosterItem::_internal_description() const {
  return description_.GetNoArena();
}
inline void RosterItem::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RosterItem::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.RosterItem.description)
}
inline void RosterItem::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.RosterItem.description)
}
inline void RosterItem::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.description)
}
inline std::string* RosterItem::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RosterItem::release_description() {
  // @@protoc_insertion_point(field_release:im.RosterItem.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return description_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RosterItem::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.description)
}

// optional string position = 6;
inline bool RosterItem::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RosterItem::has_position() const {
  return _internal_has_position();
}
inline void RosterItem::clear_position() {
  position_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RosterItem::position() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.position)
  return _internal_position();
}
inline void RosterItem::set_position(const std::string& value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.position)
}
inline std::string* RosterItem::mutable_position() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.position)
  return _internal_mutable_position();
}
inline const std::string& RosterItem::_internal_position() const {
  return position_.GetNoArena();
}
inline void RosterItem::_internal_set_position(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  position_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RosterItem::set_position(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  position_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.RosterItem.position)
}
inline void RosterItem::set_position(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  position_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.RosterItem.position)
}
inline void RosterItem::set_position(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  position_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.position)
}
inline std::string* RosterItem::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000008u;
  return position_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RosterItem::release_position() {
  // @@protoc_insertion_point(field_release:im.RosterItem.position)
  if (!has_position()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return position_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RosterItem::set_allocated_position(std::string* position) {
  if (position != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  position_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), position);
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.position)
}

// optional string department = 7;
inline bool RosterItem::_internal_has_department() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RosterItem::has_department() const {
  return _internal_has_department();
}
inline void RosterItem::clear_department() {
  department_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RosterItem::department() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.department)
  return _internal_department();
}
inline void RosterItem::set_department(const std::string& value) {
  _internal_set_department(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.department)
}
inline std::string* RosterItem::mutable_department() {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.department)
  return _internal_mutable_department();
}
inline const std::string& RosterItem::_internal_department() const {
  return department_.GetNoArena();
}
inline void RosterItem::_internal_set_department(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  department_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RosterItem::set_department(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  department_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.RosterItem.department)
}
inline void RosterItem::set_department(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  department_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.RosterItem.department)
}
inline void RosterItem::set_department(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  department_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.department)
}
inline std::string* RosterItem::_internal_mutable_department() {
  _has_bits_[0] |= 0x00000010u;
  return department_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RosterItem::release_department() {
  // @@protoc_insertion_point(field_release:im.RosterItem.department)
  if (!has_department()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return department_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RosterItem::set_allocated_department(std::string* department) {
  if (department != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  department_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), department);
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.department)
}

// repeated string groupTag = 8;
inline int RosterItem::_internal_grouptag_size() const {
  return grouptag_.size();
}
inline int RosterItem::grouptag_size() const {
  return _internal_grouptag_size();
}
inline void RosterItem::clear_grouptag() {
  grouptag_.Clear();
}
inline std::string* RosterItem::add_grouptag() {
  // @@protoc_insertion_point(field_add_mutable:im.RosterItem.groupTag)
  return _internal_add_grouptag();
}
inline const std::string& RosterItem::_internal_grouptag(int index) const {
  return grouptag_.Get(index);
}
inline const std::string& RosterItem::grouptag(int index) const {
  // @@protoc_insertion_point(field_get:im.RosterItem.groupTag)
  return _internal_grouptag(index);
}
inline std::string* RosterItem::mutable_grouptag(int index) {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.groupTag)
  return grouptag_.Mutable(index);
}
inline void RosterItem::set_grouptag(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:im.RosterItem.groupTag)
  grouptag_.Mutable(index)->assign(value);
}
inline void RosterItem::set_grouptag(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:im.RosterItem.groupTag)
  grouptag_.Mutable(index)->assign(std::move(value));
}
inline void RosterItem::set_grouptag(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  grouptag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.groupTag)
}
inline void RosterItem::set_grouptag(int index, const char* value, size_t size) {
  grouptag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.groupTag)
}
inline std::string* RosterItem::_internal_add_grouptag() {
  return grouptag_.Add();
}
inline void RosterItem::add_grouptag(const std::string& value) {
  grouptag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:im.RosterItem.groupTag)
}
inline void RosterItem::add_grouptag(std::string&& value) {
  grouptag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:im.RosterItem.groupTag)
}
inline void RosterItem::add_grouptag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  grouptag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:im.RosterItem.groupTag)
}
inline void RosterItem::add_grouptag(const char* value, size_t size) {
  grouptag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:im.RosterItem.groupTag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RosterItem::grouptag() const {
  // @@protoc_insertion_point(field_list:im.RosterItem.groupTag)
  return grouptag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RosterItem::mutable_grouptag() {
  // @@protoc_insertion_point(field_mutable_list:im.RosterItem.groupTag)
  return &grouptag_;
}

// -------------------------------------------------------------------

// RosterResp

// repeated .im.RosterItem rosterItems = 1;
inline int RosterResp::_internal_rosteritems_size() const {
  return rosteritems_.size();
}
inline int RosterResp::rosteritems_size() const {
  return _internal_rosteritems_size();
}
inline void RosterResp::clear_rosteritems() {
  rosteritems_.Clear();
}
inline ::im::RosterItem* RosterResp::mutable_rosteritems(int index) {
  // @@protoc_insertion_point(field_mutable:im.RosterResp.rosterItems)
  return rosteritems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::RosterItem >*
RosterResp::mutable_rosteritems() {
  // @@protoc_insertion_point(field_mutable_list:im.RosterResp.rosterItems)
  return &rosteritems_;
}
inline const ::im::RosterItem& RosterResp::_internal_rosteritems(int index) const {
  return rosteritems_.Get(index);
}
inline const ::im::RosterItem& RosterResp::rosteritems(int index) const {
  // @@protoc_insertion_point(field_get:im.RosterResp.rosterItems)
  return _internal_rosteritems(index);
}
inline ::im::RosterItem* RosterResp::_internal_add_rosteritems() {
  return rosteritems_.Add();
}
inline ::im::RosterItem* RosterResp::add_rosteritems() {
  // @@protoc_insertion_point(field_add:im.RosterResp.rosterItems)
  return _internal_add_rosteritems();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::RosterItem >&
RosterResp::rosteritems() const {
  // @@protoc_insertion_point(field_list:im.RosterResp.rosterItems)
  return rosteritems_;
}

// -------------------------------------------------------------------

// PresenceReq

// required .core.Jid jid = 1;
inline bool PresenceReq::_internal_has_jid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || jid_ != nullptr);
  return value;
}
inline bool PresenceReq::has_jid() const {
  return _internal_has_jid();
}
inline const ::core::Jid& PresenceReq::_internal_jid() const {
  const ::core::Jid* p = jid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& PresenceReq::jid() const {
  // @@protoc_insertion_point(field_get:im.PresenceReq.jid)
  return _internal_jid();
}
inline ::core::Jid* PresenceReq::release_jid() {
  // @@protoc_insertion_point(field_release:im.PresenceReq.jid)
  _has_bits_[0] &= ~0x00000001u;
  ::core::Jid* temp = jid_;
  jid_ = nullptr;
  return temp;
}
inline ::core::Jid* PresenceReq::_internal_mutable_jid() {
  _has_bits_[0] |= 0x00000001u;
  if (jid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    jid_ = p;
  }
  return jid_;
}
inline ::core::Jid* PresenceReq::mutable_jid() {
  // @@protoc_insertion_point(field_mutable:im.PresenceReq.jid)
  return _internal_mutable_jid();
}
inline void PresenceReq::set_allocated_jid(::core::Jid* jid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(jid_);
  }
  if (jid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      jid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  jid_ = jid;
  // @@protoc_insertion_point(field_set_allocated:im.PresenceReq.jid)
}

// -------------------------------------------------------------------

// PresenceResp

// repeated .core.Jid jids = 1;
inline int PresenceResp::_internal_jids_size() const {
  return jids_.size();
}
inline int PresenceResp::jids_size() const {
  return _internal_jids_size();
}
inline ::core::Jid* PresenceResp::mutable_jids(int index) {
  // @@protoc_insertion_point(field_mutable:im.PresenceResp.jids)
  return jids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::core::Jid >*
PresenceResp::mutable_jids() {
  // @@protoc_insertion_point(field_mutable_list:im.PresenceResp.jids)
  return &jids_;
}
inline const ::core::Jid& PresenceResp::_internal_jids(int index) const {
  return jids_.Get(index);
}
inline const ::core::Jid& PresenceResp::jids(int index) const {
  // @@protoc_insertion_point(field_get:im.PresenceResp.jids)
  return _internal_jids(index);
}
inline ::core::Jid* PresenceResp::_internal_add_jids() {
  return jids_.Add();
}
inline ::core::Jid* PresenceResp::add_jids() {
  // @@protoc_insertion_point(field_add:im.PresenceResp.jids)
  return _internal_add_jids();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::core::Jid >&
PresenceResp::jids() const {
  // @@protoc_insertion_point(field_list:im.PresenceResp.jids)
  return jids_;
}

// -------------------------------------------------------------------

// MessageElement

// required .im.EnumMessageElement kind = 1;
inline bool MessageElement::_internal_has_kind() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageElement::has_kind() const {
  return _internal_has_kind();
}
inline void MessageElement::clear_kind() {
  kind_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::im::EnumMessageElement MessageElement::_internal_kind() const {
  return static_cast< ::im::EnumMessageElement >(kind_);
}
inline ::im::EnumMessageElement MessageElement::kind() const {
  // @@protoc_insertion_point(field_get:im.MessageElement.kind)
  return _internal_kind();
}
inline void MessageElement::_internal_set_kind(::im::EnumMessageElement value) {
  assert(::im::EnumMessageElement_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  kind_ = value;
}
inline void MessageElement::set_kind(::im::EnumMessageElement value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:im.MessageElement.kind)
}

// required bytes data = 2;
inline bool MessageElement::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageElement::has_data() const {
  return _internal_has_data();
}
inline void MessageElement::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageElement::data() const {
  // @@protoc_insertion_point(field_get:im.MessageElement.data)
  return _internal_data();
}
inline void MessageElement::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:im.MessageElement.data)
}
inline std::string* MessageElement::mutable_data() {
  // @@protoc_insertion_point(field_mutable:im.MessageElement.data)
  return _internal_mutable_data();
}
inline const std::string& MessageElement::_internal_data() const {
  return data_.GetNoArena();
}
inline void MessageElement::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void MessageElement::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.MessageElement.data)
}
inline void MessageElement::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.MessageElement.data)
}
inline void MessageElement::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.MessageElement.data)
}
inline std::string* MessageElement::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MessageElement::release_data() {
  // @@protoc_insertion_point(field_release:im.MessageElement.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MessageElement::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:im.MessageElement.data)
}

// -------------------------------------------------------------------

// ChatMessage

// required .core.Jid fromJid = 1;
inline bool ChatMessage::_internal_has_fromjid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || fromjid_ != nullptr);
  return value;
}
inline bool ChatMessage::has_fromjid() const {
  return _internal_has_fromjid();
}
inline const ::core::Jid& ChatMessage::_internal_fromjid() const {
  const ::core::Jid* p = fromjid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& ChatMessage::fromjid() const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.fromJid)
  return _internal_fromjid();
}
inline ::core::Jid* ChatMessage::release_fromjid() {
  // @@protoc_insertion_point(field_release:im.ChatMessage.fromJid)
  _has_bits_[0] &= ~0x00000001u;
  ::core::Jid* temp = fromjid_;
  fromjid_ = nullptr;
  return temp;
}
inline ::core::Jid* ChatMessage::_internal_mutable_fromjid() {
  _has_bits_[0] |= 0x00000001u;
  if (fromjid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    fromjid_ = p;
  }
  return fromjid_;
}
inline ::core::Jid* ChatMessage::mutable_fromjid() {
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.fromJid)
  return _internal_mutable_fromjid();
}
inline void ChatMessage::set_allocated_fromjid(::core::Jid* fromjid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fromjid_);
  }
  if (fromjid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fromjid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fromjid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fromjid_ = fromjid;
  // @@protoc_insertion_point(field_set_allocated:im.ChatMessage.fromJid)
}

// required .core.Jid toJid = 2;
inline bool ChatMessage::_internal_has_tojid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tojid_ != nullptr);
  return value;
}
inline bool ChatMessage::has_tojid() const {
  return _internal_has_tojid();
}
inline const ::core::Jid& ChatMessage::_internal_tojid() const {
  const ::core::Jid* p = tojid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::core::Jid*>(
      &::core::_Jid_default_instance_);
}
inline const ::core::Jid& ChatMessage::tojid() const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.toJid)
  return _internal_tojid();
}
inline ::core::Jid* ChatMessage::release_tojid() {
  // @@protoc_insertion_point(field_release:im.ChatMessage.toJid)
  _has_bits_[0] &= ~0x00000002u;
  ::core::Jid* temp = tojid_;
  tojid_ = nullptr;
  return temp;
}
inline ::core::Jid* ChatMessage::_internal_mutable_tojid() {
  _has_bits_[0] |= 0x00000002u;
  if (tojid_ == nullptr) {
    auto* p = CreateMaybeMessage<::core::Jid>(GetArenaNoVirtual());
    tojid_ = p;
  }
  return tojid_;
}
inline ::core::Jid* ChatMessage::mutable_tojid() {
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.toJid)
  return _internal_mutable_tojid();
}
inline void ChatMessage::set_allocated_tojid(::core::Jid* tojid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tojid_);
  }
  if (tojid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tojid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tojid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tojid_ = tojid;
  // @@protoc_insertion_point(field_set_allocated:im.ChatMessage.toJid)
}

// repeated .im.MessageElement body = 3;
inline int ChatMessage::_internal_body_size() const {
  return body_.size();
}
inline int ChatMessage::body_size() const {
  return _internal_body_size();
}
inline void ChatMessage::clear_body() {
  body_.Clear();
}
inline ::im::MessageElement* ChatMessage::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.body)
  return body_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::MessageElement >*
ChatMessage::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:im.ChatMessage.body)
  return &body_;
}
inline const ::im::MessageElement& ChatMessage::_internal_body(int index) const {
  return body_.Get(index);
}
inline const ::im::MessageElement& ChatMessage::body(int index) const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.body)
  return _internal_body(index);
}
inline ::im::MessageElement* ChatMessage::_internal_add_body() {
  return body_.Add();
}
inline ::im::MessageElement* ChatMessage::add_body() {
  // @@protoc_insertion_point(field_add:im.ChatMessage.body)
  return _internal_add_body();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::im::MessageElement >&
ChatMessage::body() const {
  // @@protoc_insertion_point(field_list:im.ChatMessage.body)
  return body_;
}

// -------------------------------------------------------------------

// AlertMessage

// required string body = 3;
inline bool AlertMessage::_internal_has_body() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AlertMessage::has_body() const {
  return _internal_has_body();
}
inline void AlertMessage::clear_body() {
  body_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AlertMessage::body() const {
  // @@protoc_insertion_point(field_get:im.AlertMessage.body)
  return _internal_body();
}
inline void AlertMessage::set_body(const std::string& value) {
  _internal_set_body(value);
  // @@protoc_insertion_point(field_set:im.AlertMessage.body)
}
inline std::string* AlertMessage::mutable_body() {
  // @@protoc_insertion_point(field_mutable:im.AlertMessage.body)
  return _internal_mutable_body();
}
inline const std::string& AlertMessage::_internal_body() const {
  return body_.GetNoArena();
}
inline void AlertMessage::_internal_set_body(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  body_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AlertMessage::set_body(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  body_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.AlertMessage.body)
}
inline void AlertMessage::set_body(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  body_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.AlertMessage.body)
}
inline void AlertMessage::set_body(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  body_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.AlertMessage.body)
}
inline std::string* AlertMessage::_internal_mutable_body() {
  _has_bits_[0] |= 0x00000001u;
  return body_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AlertMessage::release_body() {
  // @@protoc_insertion_point(field_release:im.AlertMessage.body)
  if (!has_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return body_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AlertMessage::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  body_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:im.AlertMessage.body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::im::Presence_Show> : ::std::true_type {};
template <> struct is_proto_enum< ::im::EnumMessageElement> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_im_2eproto
