// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "core.pb.h"
// @@protoc_insertion_point(includes)

namespace im {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class Presence;
class RosterReq;
class RosterItem;
class RosterResp;
class PresenceReq;
class PresenceResp;
class MessageElement;
class ChatMessage;
class AlertMessage;

enum Presence_Show {
  Presence_Show_ONLINE = 0,
  Presence_Show_OFFLINE = 1,
  Presence_Show_AWAY = 2
};
bool Presence_Show_IsValid(int value);
const Presence_Show Presence_Show_Show_MIN = Presence_Show_ONLINE;
const Presence_Show Presence_Show_Show_MAX = Presence_Show_AWAY;
const int Presence_Show_Show_ARRAYSIZE = Presence_Show_Show_MAX + 1;

enum EnumMessageElement {
  TEXT = 0,
  SMILEY = 1,
  BITMAP = 2
};
bool EnumMessageElement_IsValid(int value);
const EnumMessageElement EnumMessageElement_MIN = TEXT;
const EnumMessageElement EnumMessageElement_MAX = BITMAP;
const int EnumMessageElement_ARRAYSIZE = EnumMessageElement_MAX + 1;

// ===================================================================

class Presence : public ::google::protobuf::MessageLite {
 public:
  Presence();
  virtual ~Presence();

  Presence(const Presence& from);

  inline Presence& operator=(const Presence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Presence& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Presence* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Presence* other);

  // implements Message ----------------------------------------------

  Presence* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Presence& from);
  void MergeFrom(const Presence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Presence_Show Show;
  static const Show ONLINE = Presence_Show_ONLINE;
  static const Show OFFLINE = Presence_Show_OFFLINE;
  static const Show AWAY = Presence_Show_AWAY;
  static inline bool Show_IsValid(int value) {
    return Presence_Show_IsValid(value);
  }
  static const Show Show_MIN =
    Presence_Show_Show_MIN;
  static const Show Show_MAX =
    Presence_Show_Show_MAX;
  static const int Show_ARRAYSIZE =
    Presence_Show_Show_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .core.Jid fromJid = 1;
  inline bool has_fromjid() const;
  inline void clear_fromjid();
  static const int kFromJidFieldNumber = 1;
  inline const ::core::Jid& fromjid() const;
  inline ::core::Jid* mutable_fromjid();
  inline ::core::Jid* release_fromjid();
  inline void set_allocated_fromjid(::core::Jid* fromjid);

  // optional .core.Jid toJid = 2;
  inline bool has_tojid() const;
  inline void clear_tojid();
  static const int kToJidFieldNumber = 2;
  inline const ::core::Jid& tojid() const;
  inline ::core::Jid* mutable_tojid();
  inline ::core::Jid* release_tojid();
  inline void set_allocated_tojid(::core::Jid* tojid);

  // optional int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional .im.Presence.Show show = 5;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 5;
  inline ::im::Presence_Show show() const;
  inline void set_show(::im::Presence_Show value);

  // optional string status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:im.Presence)
 private:
  inline void set_has_fromjid();
  inline void clear_has_fromjid();
  inline void set_has_tojid();
  inline void clear_has_tojid();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* fromjid_;
  ::core::Jid* tojid_;
  ::google::protobuf::int32 priority_;
  int show_;
  ::std::string* status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static Presence* default_instance_;
};
// -------------------------------------------------------------------

class RosterReq : public ::google::protobuf::MessageLite {
 public:
  RosterReq();
  virtual ~RosterReq();

  RosterReq(const RosterReq& from);

  inline RosterReq& operator=(const RosterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RosterReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RosterReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RosterReq* other);

  // implements Message ----------------------------------------------

  RosterReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RosterReq& from);
  void MergeFrom(const RosterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Jid jid = 1;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 1;
  inline const ::core::Jid& jid() const;
  inline ::core::Jid* mutable_jid();
  inline ::core::Jid* release_jid();
  inline void set_allocated_jid(::core::Jid* jid);

  // @@protoc_insertion_point(class_scope:im.RosterReq)
 private:
  inline void set_has_jid();
  inline void clear_has_jid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* jid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static RosterReq* default_instance_;
};
// -------------------------------------------------------------------

class RosterItem : public ::google::protobuf::MessageLite {
 public:
  RosterItem();
  virtual ~RosterItem();

  RosterItem(const RosterItem& from);

  inline RosterItem& operator=(const RosterItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RosterItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RosterItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RosterItem* other);

  // implements Message ----------------------------------------------

  RosterItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RosterItem& from);
  void MergeFrom(const RosterItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Jid jid = 1;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 1;
  inline const ::core::Jid& jid() const;
  inline ::core::Jid* mutable_jid();
  inline ::core::Jid* release_jid();
  inline void set_allocated_jid(::core::Jid* jid);

  // required int32 onlineStatus = 2;
  inline bool has_onlinestatus() const;
  inline void clear_onlinestatus();
  static const int kOnlineStatusFieldNumber = 2;
  inline ::google::protobuf::int32 onlinestatus() const;
  inline void set_onlinestatus(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nickname = 4;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string position = 6;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional string department = 7;
  inline bool has_department() const;
  inline void clear_department();
  static const int kDepartmentFieldNumber = 7;
  inline const ::std::string& department() const;
  inline void set_department(const ::std::string& value);
  inline void set_department(const char* value);
  inline void set_department(const char* value, size_t size);
  inline ::std::string* mutable_department();
  inline ::std::string* release_department();
  inline void set_allocated_department(::std::string* department);

  // repeated string groupTag = 8;
  inline int grouptag_size() const;
  inline void clear_grouptag();
  static const int kGroupTagFieldNumber = 8;
  inline const ::std::string& grouptag(int index) const;
  inline ::std::string* mutable_grouptag(int index);
  inline void set_grouptag(int index, const ::std::string& value);
  inline void set_grouptag(int index, const char* value);
  inline void set_grouptag(int index, const char* value, size_t size);
  inline ::std::string* add_grouptag();
  inline void add_grouptag(const ::std::string& value);
  inline void add_grouptag(const char* value);
  inline void add_grouptag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& grouptag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_grouptag();

  // @@protoc_insertion_point(class_scope:im.RosterItem)
 private:
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_onlinestatus();
  inline void clear_has_onlinestatus();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_department();
  inline void clear_has_department();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* jid_;
  ::std::string* name_;
  ::std::string* nickname_;
  ::std::string* description_;
  ::std::string* position_;
  ::std::string* department_;
  ::google::protobuf::RepeatedPtrField< ::std::string> grouptag_;
  ::google::protobuf::int32 onlinestatus_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static RosterItem* default_instance_;
};
// -------------------------------------------------------------------

class RosterResp : public ::google::protobuf::MessageLite {
 public:
  RosterResp();
  virtual ~RosterResp();

  RosterResp(const RosterResp& from);

  inline RosterResp& operator=(const RosterResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RosterResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RosterResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RosterResp* other);

  // implements Message ----------------------------------------------

  RosterResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RosterResp& from);
  void MergeFrom(const RosterResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .im.RosterItem rosterItems = 1;
  inline int rosteritems_size() const;
  inline void clear_rosteritems();
  static const int kRosterItemsFieldNumber = 1;
  inline const ::im::RosterItem& rosteritems(int index) const;
  inline ::im::RosterItem* mutable_rosteritems(int index);
  inline ::im::RosterItem* add_rosteritems();
  inline const ::google::protobuf::RepeatedPtrField< ::im::RosterItem >&
      rosteritems() const;
  inline ::google::protobuf::RepeatedPtrField< ::im::RosterItem >*
      mutable_rosteritems();

  // @@protoc_insertion_point(class_scope:im.RosterResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::im::RosterItem > rosteritems_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static RosterResp* default_instance_;
};
// -------------------------------------------------------------------

class PresenceReq : public ::google::protobuf::MessageLite {
 public:
  PresenceReq();
  virtual ~PresenceReq();

  PresenceReq(const PresenceReq& from);

  inline PresenceReq& operator=(const PresenceReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PresenceReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PresenceReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PresenceReq* other);

  // implements Message ----------------------------------------------

  PresenceReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PresenceReq& from);
  void MergeFrom(const PresenceReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Jid jid = 1;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 1;
  inline const ::core::Jid& jid() const;
  inline ::core::Jid* mutable_jid();
  inline ::core::Jid* release_jid();
  inline void set_allocated_jid(::core::Jid* jid);

  // @@protoc_insertion_point(class_scope:im.PresenceReq)
 private:
  inline void set_has_jid();
  inline void clear_has_jid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* jid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static PresenceReq* default_instance_;
};
// -------------------------------------------------------------------

class PresenceResp : public ::google::protobuf::MessageLite {
 public:
  PresenceResp();
  virtual ~PresenceResp();

  PresenceResp(const PresenceResp& from);

  inline PresenceResp& operator=(const PresenceResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PresenceResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PresenceResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PresenceResp* other);

  // implements Message ----------------------------------------------

  PresenceResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PresenceResp& from);
  void MergeFrom(const PresenceResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .core.Jid jids = 1;
  inline int jids_size() const;
  inline void clear_jids();
  static const int kJidsFieldNumber = 1;
  inline const ::core::Jid& jids(int index) const;
  inline ::core::Jid* mutable_jids(int index);
  inline ::core::Jid* add_jids();
  inline const ::google::protobuf::RepeatedPtrField< ::core::Jid >&
      jids() const;
  inline ::google::protobuf::RepeatedPtrField< ::core::Jid >*
      mutable_jids();

  // @@protoc_insertion_point(class_scope:im.PresenceResp)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::core::Jid > jids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static PresenceResp* default_instance_;
};
// -------------------------------------------------------------------

class MessageElement : public ::google::protobuf::MessageLite {
 public:
  MessageElement();
  virtual ~MessageElement();

  MessageElement(const MessageElement& from);

  inline MessageElement& operator=(const MessageElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MessageElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageElement* other);

  // implements Message ----------------------------------------------

  MessageElement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageElement& from);
  void MergeFrom(const MessageElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .im.EnumMessageElement kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::im::EnumMessageElement kind() const;
  inline void set_kind(::im::EnumMessageElement value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:im.MessageElement)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  int kind_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static MessageElement* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::MessageLite {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChatMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  ChatMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Jid fromJid = 1;
  inline bool has_fromjid() const;
  inline void clear_fromjid();
  static const int kFromJidFieldNumber = 1;
  inline const ::core::Jid& fromjid() const;
  inline ::core::Jid* mutable_fromjid();
  inline ::core::Jid* release_fromjid();
  inline void set_allocated_fromjid(::core::Jid* fromjid);

  // required .core.Jid toJid = 2;
  inline bool has_tojid() const;
  inline void clear_tojid();
  static const int kToJidFieldNumber = 2;
  inline const ::core::Jid& tojid() const;
  inline ::core::Jid* mutable_tojid();
  inline ::core::Jid* release_tojid();
  inline void set_allocated_tojid(::core::Jid* tojid);

  // repeated .im.MessageElement body = 3;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 3;
  inline const ::im::MessageElement& body(int index) const;
  inline ::im::MessageElement* mutable_body(int index);
  inline ::im::MessageElement* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::im::MessageElement >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::im::MessageElement >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:im.ChatMessage)
 private:
  inline void set_has_fromjid();
  inline void clear_has_fromjid();
  inline void set_has_tojid();
  inline void clear_has_tojid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* fromjid_;
  ::core::Jid* tojid_;
  ::google::protobuf::RepeatedPtrField< ::im::MessageElement > body_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class AlertMessage : public ::google::protobuf::MessageLite {
 public:
  AlertMessage();
  virtual ~AlertMessage();

  AlertMessage(const AlertMessage& from);

  inline AlertMessage& operator=(const AlertMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AlertMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AlertMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AlertMessage* other);

  // implements Message ----------------------------------------------

  AlertMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AlertMessage& from);
  void MergeFrom(const AlertMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string body = 3;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 3;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:im.AlertMessage)
 private:
  inline void set_has_body();
  inline void clear_has_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* body_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static AlertMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Presence

// optional .core.Jid fromJid = 1;
inline bool Presence::has_fromjid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Presence::set_has_fromjid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Presence::clear_has_fromjid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Presence::clear_fromjid() {
  if (fromjid_ != NULL) fromjid_->::core::Jid::Clear();
  clear_has_fromjid();
}
inline const ::core::Jid& Presence::fromjid() const {
  // @@protoc_insertion_point(field_get:im.Presence.fromJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fromjid_ != NULL ? *fromjid_ : *default_instance().fromjid_;
#else
  return fromjid_ != NULL ? *fromjid_ : *default_instance_->fromjid_;
#endif
}
inline ::core::Jid* Presence::mutable_fromjid() {
  set_has_fromjid();
  if (fromjid_ == NULL) fromjid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.Presence.fromJid)
  return fromjid_;
}
inline ::core::Jid* Presence::release_fromjid() {
  clear_has_fromjid();
  ::core::Jid* temp = fromjid_;
  fromjid_ = NULL;
  return temp;
}
inline void Presence::set_allocated_fromjid(::core::Jid* fromjid) {
  delete fromjid_;
  fromjid_ = fromjid;
  if (fromjid) {
    set_has_fromjid();
  } else {
    clear_has_fromjid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.Presence.fromJid)
}

// optional .core.Jid toJid = 2;
inline bool Presence::has_tojid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Presence::set_has_tojid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Presence::clear_has_tojid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Presence::clear_tojid() {
  if (tojid_ != NULL) tojid_->::core::Jid::Clear();
  clear_has_tojid();
}
inline const ::core::Jid& Presence::tojid() const {
  // @@protoc_insertion_point(field_get:im.Presence.toJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tojid_ != NULL ? *tojid_ : *default_instance().tojid_;
#else
  return tojid_ != NULL ? *tojid_ : *default_instance_->tojid_;
#endif
}
inline ::core::Jid* Presence::mutable_tojid() {
  set_has_tojid();
  if (tojid_ == NULL) tojid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.Presence.toJid)
  return tojid_;
}
inline ::core::Jid* Presence::release_tojid() {
  clear_has_tojid();
  ::core::Jid* temp = tojid_;
  tojid_ = NULL;
  return temp;
}
inline void Presence::set_allocated_tojid(::core::Jid* tojid) {
  delete tojid_;
  tojid_ = tojid;
  if (tojid) {
    set_has_tojid();
  } else {
    clear_has_tojid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.Presence.toJid)
}

// optional int32 priority = 4;
inline bool Presence::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Presence::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Presence::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Presence::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Presence::priority() const {
  // @@protoc_insertion_point(field_get:im.Presence.priority)
  return priority_;
}
inline void Presence::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:im.Presence.priority)
}

// optional .im.Presence.Show show = 5;
inline bool Presence::has_show() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Presence::set_has_show() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Presence::clear_has_show() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Presence::clear_show() {
  show_ = 0;
  clear_has_show();
}
inline ::im::Presence_Show Presence::show() const {
  // @@protoc_insertion_point(field_get:im.Presence.show)
  return static_cast< ::im::Presence_Show >(show_);
}
inline void Presence::set_show(::im::Presence_Show value) {
  assert(::im::Presence_Show_IsValid(value));
  set_has_show();
  show_ = value;
  // @@protoc_insertion_point(field_set:im.Presence.show)
}

// optional string status = 6;
inline bool Presence::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Presence::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Presence::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Presence::clear_status() {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& Presence::status() const {
  // @@protoc_insertion_point(field_get:im.Presence.status)
  return *status_;
}
inline void Presence::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set:im.Presence.status)
}
inline void Presence::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.Presence.status)
}
inline void Presence::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.Presence.status)
}
inline ::std::string* Presence::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.Presence.status)
  return status_;
}
inline ::std::string* Presence::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Presence::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.Presence.status)
}

// -------------------------------------------------------------------

// RosterReq

// required .core.Jid jid = 1;
inline bool RosterReq::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RosterReq::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RosterReq::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RosterReq::clear_jid() {
  if (jid_ != NULL) jid_->::core::Jid::Clear();
  clear_has_jid();
}
inline const ::core::Jid& RosterReq::jid() const {
  // @@protoc_insertion_point(field_get:im.RosterReq.jid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return jid_ != NULL ? *jid_ : *default_instance().jid_;
#else
  return jid_ != NULL ? *jid_ : *default_instance_->jid_;
#endif
}
inline ::core::Jid* RosterReq::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) jid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.RosterReq.jid)
  return jid_;
}
inline ::core::Jid* RosterReq::release_jid() {
  clear_has_jid();
  ::core::Jid* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline void RosterReq::set_allocated_jid(::core::Jid* jid) {
  delete jid_;
  jid_ = jid;
  if (jid) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterReq.jid)
}

// -------------------------------------------------------------------

// RosterItem

// required .core.Jid jid = 1;
inline bool RosterItem::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RosterItem::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RosterItem::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RosterItem::clear_jid() {
  if (jid_ != NULL) jid_->::core::Jid::Clear();
  clear_has_jid();
}
inline const ::core::Jid& RosterItem::jid() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.jid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return jid_ != NULL ? *jid_ : *default_instance().jid_;
#else
  return jid_ != NULL ? *jid_ : *default_instance_->jid_;
#endif
}
inline ::core::Jid* RosterItem::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) jid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.RosterItem.jid)
  return jid_;
}
inline ::core::Jid* RosterItem::release_jid() {
  clear_has_jid();
  ::core::Jid* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline void RosterItem::set_allocated_jid(::core::Jid* jid) {
  delete jid_;
  jid_ = jid;
  if (jid) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.jid)
}

// required int32 onlineStatus = 2;
inline bool RosterItem::has_onlinestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RosterItem::set_has_onlinestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RosterItem::clear_has_onlinestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RosterItem::clear_onlinestatus() {
  onlinestatus_ = 0;
  clear_has_onlinestatus();
}
inline ::google::protobuf::int32 RosterItem::onlinestatus() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.onlineStatus)
  return onlinestatus_;
}
inline void RosterItem::set_onlinestatus(::google::protobuf::int32 value) {
  set_has_onlinestatus();
  onlinestatus_ = value;
  // @@protoc_insertion_point(field_set:im.RosterItem.onlineStatus)
}

// optional string name = 3;
inline bool RosterItem::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RosterItem::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RosterItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RosterItem::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RosterItem::name() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.name)
  return *name_;
}
inline void RosterItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.name)
}
inline void RosterItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.name)
}
inline void RosterItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.name)
}
inline ::std::string* RosterItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.RosterItem.name)
  return name_;
}
inline ::std::string* RosterItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RosterItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.name)
}

// optional string nickname = 4;
inline bool RosterItem::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RosterItem::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RosterItem::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RosterItem::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RosterItem::nickname() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.nickname)
  return *nickname_;
}
inline void RosterItem::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.nickname)
}
inline void RosterItem::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.nickname)
}
inline void RosterItem::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.nickname)
}
inline ::std::string* RosterItem::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.RosterItem.nickname)
  return nickname_;
}
inline ::std::string* RosterItem::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RosterItem::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.nickname)
}

// optional string description = 5;
inline bool RosterItem::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RosterItem::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RosterItem::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RosterItem::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& RosterItem::description() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.description)
  return *description_;
}
inline void RosterItem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.description)
}
inline void RosterItem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.description)
}
inline void RosterItem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.description)
}
inline ::std::string* RosterItem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.RosterItem.description)
  return description_;
}
inline ::std::string* RosterItem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RosterItem::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.description)
}

// optional string position = 6;
inline bool RosterItem::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RosterItem::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RosterItem::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RosterItem::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& RosterItem::position() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.position)
  return *position_;
}
inline void RosterItem::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.position)
}
inline void RosterItem::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.position)
}
inline void RosterItem::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.position)
}
inline ::std::string* RosterItem::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.RosterItem.position)
  return position_;
}
inline ::std::string* RosterItem::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RosterItem::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.position)
}

// optional string department = 7;
inline bool RosterItem::has_department() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RosterItem::set_has_department() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RosterItem::clear_has_department() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RosterItem::clear_department() {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_->clear();
  }
  clear_has_department();
}
inline const ::std::string& RosterItem::department() const {
  // @@protoc_insertion_point(field_get:im.RosterItem.department)
  return *department_;
}
inline void RosterItem::set_department(const ::std::string& value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set:im.RosterItem.department)
}
inline void RosterItem::set_department(const char* value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.department)
}
inline void RosterItem::set_department(const char* value, size_t size) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.department)
}
inline ::std::string* RosterItem::mutable_department() {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.RosterItem.department)
  return department_;
}
inline ::std::string* RosterItem::release_department() {
  clear_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = department_;
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RosterItem::set_allocated_department(::std::string* department) {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete department_;
  }
  if (department) {
    set_has_department();
    department_ = department;
  } else {
    clear_has_department();
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.RosterItem.department)
}

// repeated string groupTag = 8;
inline int RosterItem::grouptag_size() const {
  return grouptag_.size();
}
inline void RosterItem::clear_grouptag() {
  grouptag_.Clear();
}
inline const ::std::string& RosterItem::grouptag(int index) const {
  // @@protoc_insertion_point(field_get:im.RosterItem.groupTag)
  return grouptag_.Get(index);
}
inline ::std::string* RosterItem::mutable_grouptag(int index) {
  // @@protoc_insertion_point(field_mutable:im.RosterItem.groupTag)
  return grouptag_.Mutable(index);
}
inline void RosterItem::set_grouptag(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:im.RosterItem.groupTag)
  grouptag_.Mutable(index)->assign(value);
}
inline void RosterItem::set_grouptag(int index, const char* value) {
  grouptag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:im.RosterItem.groupTag)
}
inline void RosterItem::set_grouptag(int index, const char* value, size_t size) {
  grouptag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.RosterItem.groupTag)
}
inline ::std::string* RosterItem::add_grouptag() {
  return grouptag_.Add();
}
inline void RosterItem::add_grouptag(const ::std::string& value) {
  grouptag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:im.RosterItem.groupTag)
}
inline void RosterItem::add_grouptag(const char* value) {
  grouptag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:im.RosterItem.groupTag)
}
inline void RosterItem::add_grouptag(const char* value, size_t size) {
  grouptag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:im.RosterItem.groupTag)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RosterItem::grouptag() const {
  // @@protoc_insertion_point(field_list:im.RosterItem.groupTag)
  return grouptag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RosterItem::mutable_grouptag() {
  // @@protoc_insertion_point(field_mutable_list:im.RosterItem.groupTag)
  return &grouptag_;
}

// -------------------------------------------------------------------

// RosterResp

// repeated .im.RosterItem rosterItems = 1;
inline int RosterResp::rosteritems_size() const {
  return rosteritems_.size();
}
inline void RosterResp::clear_rosteritems() {
  rosteritems_.Clear();
}
inline const ::im::RosterItem& RosterResp::rosteritems(int index) const {
  // @@protoc_insertion_point(field_get:im.RosterResp.rosterItems)
  return rosteritems_.Get(index);
}
inline ::im::RosterItem* RosterResp::mutable_rosteritems(int index) {
  // @@protoc_insertion_point(field_mutable:im.RosterResp.rosterItems)
  return rosteritems_.Mutable(index);
}
inline ::im::RosterItem* RosterResp::add_rosteritems() {
  // @@protoc_insertion_point(field_add:im.RosterResp.rosterItems)
  return rosteritems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::im::RosterItem >&
RosterResp::rosteritems() const {
  // @@protoc_insertion_point(field_list:im.RosterResp.rosterItems)
  return rosteritems_;
}
inline ::google::protobuf::RepeatedPtrField< ::im::RosterItem >*
RosterResp::mutable_rosteritems() {
  // @@protoc_insertion_point(field_mutable_list:im.RosterResp.rosterItems)
  return &rosteritems_;
}

// -------------------------------------------------------------------

// PresenceReq

// required .core.Jid jid = 1;
inline bool PresenceReq::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresenceReq::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresenceReq::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresenceReq::clear_jid() {
  if (jid_ != NULL) jid_->::core::Jid::Clear();
  clear_has_jid();
}
inline const ::core::Jid& PresenceReq::jid() const {
  // @@protoc_insertion_point(field_get:im.PresenceReq.jid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return jid_ != NULL ? *jid_ : *default_instance().jid_;
#else
  return jid_ != NULL ? *jid_ : *default_instance_->jid_;
#endif
}
inline ::core::Jid* PresenceReq::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) jid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.PresenceReq.jid)
  return jid_;
}
inline ::core::Jid* PresenceReq::release_jid() {
  clear_has_jid();
  ::core::Jid* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline void PresenceReq::set_allocated_jid(::core::Jid* jid) {
  delete jid_;
  jid_ = jid;
  if (jid) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.PresenceReq.jid)
}

// -------------------------------------------------------------------

// PresenceResp

// repeated .core.Jid jids = 1;
inline int PresenceResp::jids_size() const {
  return jids_.size();
}
inline void PresenceResp::clear_jids() {
  jids_.Clear();
}
inline const ::core::Jid& PresenceResp::jids(int index) const {
  // @@protoc_insertion_point(field_get:im.PresenceResp.jids)
  return jids_.Get(index);
}
inline ::core::Jid* PresenceResp::mutable_jids(int index) {
  // @@protoc_insertion_point(field_mutable:im.PresenceResp.jids)
  return jids_.Mutable(index);
}
inline ::core::Jid* PresenceResp::add_jids() {
  // @@protoc_insertion_point(field_add:im.PresenceResp.jids)
  return jids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::core::Jid >&
PresenceResp::jids() const {
  // @@protoc_insertion_point(field_list:im.PresenceResp.jids)
  return jids_;
}
inline ::google::protobuf::RepeatedPtrField< ::core::Jid >*
PresenceResp::mutable_jids() {
  // @@protoc_insertion_point(field_mutable_list:im.PresenceResp.jids)
  return &jids_;
}

// -------------------------------------------------------------------

// MessageElement

// required .im.EnumMessageElement kind = 1;
inline bool MessageElement::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageElement::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageElement::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageElement::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::im::EnumMessageElement MessageElement::kind() const {
  // @@protoc_insertion_point(field_get:im.MessageElement.kind)
  return static_cast< ::im::EnumMessageElement >(kind_);
}
inline void MessageElement::set_kind(::im::EnumMessageElement value) {
  assert(::im::EnumMessageElement_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:im.MessageElement.kind)
}

// required bytes data = 2;
inline bool MessageElement::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageElement::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageElement::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageElement::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MessageElement::data() const {
  // @@protoc_insertion_point(field_get:im.MessageElement.data)
  return *data_;
}
inline void MessageElement::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:im.MessageElement.data)
}
inline void MessageElement::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.MessageElement.data)
}
inline void MessageElement::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.MessageElement.data)
}
inline ::std::string* MessageElement::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.MessageElement.data)
  return data_;
}
inline ::std::string* MessageElement::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageElement::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.MessageElement.data)
}

// -------------------------------------------------------------------

// ChatMessage

// required .core.Jid fromJid = 1;
inline bool ChatMessage::has_fromjid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_fromjid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_fromjid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_fromjid() {
  if (fromjid_ != NULL) fromjid_->::core::Jid::Clear();
  clear_has_fromjid();
}
inline const ::core::Jid& ChatMessage::fromjid() const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.fromJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fromjid_ != NULL ? *fromjid_ : *default_instance().fromjid_;
#else
  return fromjid_ != NULL ? *fromjid_ : *default_instance_->fromjid_;
#endif
}
inline ::core::Jid* ChatMessage::mutable_fromjid() {
  set_has_fromjid();
  if (fromjid_ == NULL) fromjid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.fromJid)
  return fromjid_;
}
inline ::core::Jid* ChatMessage::release_fromjid() {
  clear_has_fromjid();
  ::core::Jid* temp = fromjid_;
  fromjid_ = NULL;
  return temp;
}
inline void ChatMessage::set_allocated_fromjid(::core::Jid* fromjid) {
  delete fromjid_;
  fromjid_ = fromjid;
  if (fromjid) {
    set_has_fromjid();
  } else {
    clear_has_fromjid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.ChatMessage.fromJid)
}

// required .core.Jid toJid = 2;
inline bool ChatMessage::has_tojid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_tojid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_tojid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_tojid() {
  if (tojid_ != NULL) tojid_->::core::Jid::Clear();
  clear_has_tojid();
}
inline const ::core::Jid& ChatMessage::tojid() const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.toJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tojid_ != NULL ? *tojid_ : *default_instance().tojid_;
#else
  return tojid_ != NULL ? *tojid_ : *default_instance_->tojid_;
#endif
}
inline ::core::Jid* ChatMessage::mutable_tojid() {
  set_has_tojid();
  if (tojid_ == NULL) tojid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.toJid)
  return tojid_;
}
inline ::core::Jid* ChatMessage::release_tojid() {
  clear_has_tojid();
  ::core::Jid* temp = tojid_;
  tojid_ = NULL;
  return temp;
}
inline void ChatMessage::set_allocated_tojid(::core::Jid* tojid) {
  delete tojid_;
  tojid_ = tojid;
  if (tojid) {
    set_has_tojid();
  } else {
    clear_has_tojid();
  }
  // @@protoc_insertion_point(field_set_allocated:im.ChatMessage.toJid)
}

// repeated .im.MessageElement body = 3;
inline int ChatMessage::body_size() const {
  return body_.size();
}
inline void ChatMessage::clear_body() {
  body_.Clear();
}
inline const ::im::MessageElement& ChatMessage::body(int index) const {
  // @@protoc_insertion_point(field_get:im.ChatMessage.body)
  return body_.Get(index);
}
inline ::im::MessageElement* ChatMessage::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:im.ChatMessage.body)
  return body_.Mutable(index);
}
inline ::im::MessageElement* ChatMessage::add_body() {
  // @@protoc_insertion_point(field_add:im.ChatMessage.body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::im::MessageElement >&
ChatMessage::body() const {
  // @@protoc_insertion_point(field_list:im.ChatMessage.body)
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::im::MessageElement >*
ChatMessage::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:im.ChatMessage.body)
  return &body_;
}

// -------------------------------------------------------------------

// AlertMessage

// required string body = 3;
inline bool AlertMessage::has_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertMessage::set_has_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertMessage::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& AlertMessage::body() const {
  // @@protoc_insertion_point(field_get:im.AlertMessage.body)
  return *body_;
}
inline void AlertMessage::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:im.AlertMessage.body)
}
inline void AlertMessage::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:im.AlertMessage.body)
}
inline void AlertMessage::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:im.AlertMessage.body)
}
inline ::std::string* AlertMessage::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:im.AlertMessage.body)
  return body_;
}
inline ::std::string* AlertMessage::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AlertMessage::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:im.AlertMessage.body)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
