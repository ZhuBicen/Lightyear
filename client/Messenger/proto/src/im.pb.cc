// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#include "im.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_core_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Jid_core_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_im_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MessageElement_im_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_im_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RosterItem_im_2eproto;
namespace im {
class PresenceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Presence> _instance;
} _Presence_default_instance_;
class RosterReqDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RosterReq> _instance;
} _RosterReq_default_instance_;
class RosterItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RosterItem> _instance;
} _RosterItem_default_instance_;
class RosterRespDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RosterResp> _instance;
} _RosterResp_default_instance_;
class PresenceReqDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PresenceReq> _instance;
} _PresenceReq_default_instance_;
class PresenceRespDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PresenceResp> _instance;
} _PresenceResp_default_instance_;
class MessageElementDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MessageElement> _instance;
} _MessageElement_default_instance_;
class ChatMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ChatMessage> _instance;
} _ChatMessage_default_instance_;
class AlertMessageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AlertMessage> _instance;
} _AlertMessage_default_instance_;
}  // namespace im
static void InitDefaultsscc_info_AlertMessage_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_AlertMessage_default_instance_;
    new (ptr) ::im::AlertMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::AlertMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AlertMessage_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AlertMessage_im_2eproto}, {}};

static void InitDefaultsscc_info_ChatMessage_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_ChatMessage_default_instance_;
    new (ptr) ::im::ChatMessage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::ChatMessage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ChatMessage_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ChatMessage_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,
      &scc_info_MessageElement_im_2eproto.base,}};

static void InitDefaultsscc_info_MessageElement_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_MessageElement_default_instance_;
    new (ptr) ::im::MessageElement();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::MessageElement::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MessageElement_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MessageElement_im_2eproto}, {}};

static void InitDefaultsscc_info_Presence_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_Presence_default_instance_;
    new (ptr) ::im::Presence();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::Presence::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Presence_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Presence_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_PresenceReq_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_PresenceReq_default_instance_;
    new (ptr) ::im::PresenceReq();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::PresenceReq::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PresenceReq_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PresenceReq_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_PresenceResp_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_PresenceResp_default_instance_;
    new (ptr) ::im::PresenceResp();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::PresenceResp::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PresenceResp_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PresenceResp_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_RosterItem_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_RosterItem_default_instance_;
    new (ptr) ::im::RosterItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::RosterItem::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RosterItem_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RosterItem_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_RosterReq_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_RosterReq_default_instance_;
    new (ptr) ::im::RosterReq();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::RosterReq::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RosterReq_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RosterReq_im_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_RosterResp_im_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::im::_RosterResp_default_instance_;
    new (ptr) ::im::RosterResp();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::im::RosterResp::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RosterResp_im_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RosterResp_im_2eproto}, {
      &scc_info_RosterItem_im_2eproto.base,}};

namespace im {
bool Presence_Show_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Presence_Show_strings[3] = {};

static const char Presence_Show_names[] =
  "AWAY"
  "OFFLINE"
  "ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Presence_Show_entries[] = {
  { {Presence_Show_names + 0, 4}, 2 },
  { {Presence_Show_names + 4, 7}, 1 },
  { {Presence_Show_names + 11, 6}, 0 },
};

static const int Presence_Show_entries_by_number[] = {
  2, // 0 -> ONLINE
  1, // 1 -> OFFLINE
  0, // 2 -> AWAY
};

const std::string& Presence_Show_Name(
    Presence_Show value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Presence_Show_entries,
          Presence_Show_entries_by_number,
          3, Presence_Show_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Presence_Show_entries,
      Presence_Show_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Presence_Show_strings[idx].get();
}
bool Presence_Show_Parse(
    const std::string& name, Presence_Show* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Presence_Show_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Presence_Show>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Presence_Show Presence::ONLINE;
constexpr Presence_Show Presence::OFFLINE;
constexpr Presence_Show Presence::AWAY;
constexpr Presence_Show Presence::Show_MIN;
constexpr Presence_Show Presence::Show_MAX;
constexpr int Presence::Show_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EnumMessageElement_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EnumMessageElement_strings[3] = {};

static const char EnumMessageElement_names[] =
  "BITMAP"
  "SMILEY"
  "TEXT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EnumMessageElement_entries[] = {
  { {EnumMessageElement_names + 0, 6}, 2 },
  { {EnumMessageElement_names + 6, 6}, 1 },
  { {EnumMessageElement_names + 12, 4}, 0 },
};

static const int EnumMessageElement_entries_by_number[] = {
  2, // 0 -> TEXT
  1, // 1 -> SMILEY
  0, // 2 -> BITMAP
};

const std::string& EnumMessageElement_Name(
    EnumMessageElement value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EnumMessageElement_entries,
          EnumMessageElement_entries_by_number,
          3, EnumMessageElement_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EnumMessageElement_entries,
      EnumMessageElement_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EnumMessageElement_strings[idx].get();
}
bool EnumMessageElement_Parse(
    const std::string& name, EnumMessageElement* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EnumMessageElement_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EnumMessageElement>(int_value);
  }
  return success;
}

// ===================================================================

void Presence::InitAsDefaultInstance() {
  ::im::_Presence_default_instance_._instance.get_mutable()->fromjid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
  ::im::_Presence_default_instance_._instance.get_mutable()->tojid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class Presence::_Internal {
 public:
  using HasBits = decltype(std::declval<Presence>()._has_bits_);
  static const ::core::Jid& fromjid(const Presence* msg);
  static void set_has_fromjid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::core::Jid& tojid(const Presence* msg);
  static void set_has_tojid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_show(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::core::Jid&
Presence::_Internal::fromjid(const Presence* msg) {
  return *msg->fromjid_;
}
const ::core::Jid&
Presence::_Internal::tojid(const Presence* msg) {
  return *msg->tojid_;
}
void Presence::clear_fromjid() {
  if (fromjid_ != nullptr) fromjid_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Presence::clear_tojid() {
  if (tojid_ != nullptr) tojid_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
Presence::Presence()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.Presence)
}
Presence::Presence(const Presence& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_status()) {
    status_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.status_);
  }
  if (from._internal_has_fromjid()) {
    fromjid_ = new ::core::Jid(*from.fromjid_);
  } else {
    fromjid_ = nullptr;
  }
  if (from._internal_has_tojid()) {
    tojid_ = new ::core::Jid(*from.tojid_);
  } else {
    tojid_ = nullptr;
  }
  ::memcpy(&priority_, &from.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(show_));
  // @@protoc_insertion_point(copy_constructor:im.Presence)
}

void Presence::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Presence_im_2eproto.base);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&fromjid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&show_) -
      reinterpret_cast<char*>(&fromjid_)) + sizeof(show_));
}

Presence::~Presence() {
  // @@protoc_insertion_point(destructor:im.Presence)
  SharedDtor();
}

void Presence::SharedDtor() {
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete fromjid_;
  if (this != internal_default_instance()) delete tojid_;
}

void Presence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Presence& Presence::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Presence_im_2eproto.base);
  return *internal_default_instance();
}


void Presence::Clear() {
// @@protoc_insertion_point(message_clear_start:im.Presence)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      status_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fromjid_ != nullptr);
      fromjid_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(tojid_ != nullptr);
      tojid_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_) -
        reinterpret_cast<char*>(&priority_)) + sizeof(show_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Presence::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .core.Jid fromJid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fromjid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .core.Jid toJid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tojid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 priority = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .im.Presence.Show show = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::im::Presence_Show_IsValid(val))) {
            _internal_set_show(static_cast<::im::Presence_Show>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_status(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Presence::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.Presence)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .core.Jid fromJid = 1;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::fromjid(this), target, stream);
  }

  // optional .core.Jid toJid = 2;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::tojid(this), target, stream);
  }

  // optional int32 priority = 4;
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_priority(), target);
  }

  // optional .im.Presence.Show show = 5;
  if (cached_has_bits & 0x00000010u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_show(), target);
  }

  // optional string status = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.Presence)
  return target;
}

size_t Presence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.Presence)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string status = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional .core.Jid fromJid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fromjid_);
    }

    // optional .core.Jid toJid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tojid_);
    }

    // optional int32 priority = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_priority());
    }

    // optional .im.Presence.Show show = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_show());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Presence::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Presence*>(
      &from));
}

void Presence::MergeFrom(const Presence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.Presence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      status_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.status_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fromjid()->::core::Jid::MergeFrom(from._internal_fromjid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_tojid()->::core::Jid::MergeFrom(from._internal_tojid());
    }
    if (cached_has_bits & 0x00000008u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      show_ = from.show_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Presence::CopyFrom(const Presence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.Presence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Presence::IsInitialized() const {
  if (has_fromjid()) {
    if (!this->fromjid_->IsInitialized()) return false;
  }
  if (has_tojid()) {
    if (!this->tojid_->IsInitialized()) return false;
  }
  return true;
}

void Presence::InternalSwap(Presence* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  status_.Swap(&other->status_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(fromjid_, other->fromjid_);
  swap(tojid_, other->tojid_);
  swap(priority_, other->priority_);
  swap(show_, other->show_);
}

std::string Presence::GetTypeName() const {
  return "im.Presence";
}


// ===================================================================

void RosterReq::InitAsDefaultInstance() {
  ::im::_RosterReq_default_instance_._instance.get_mutable()->jid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class RosterReq::_Internal {
 public:
  using HasBits = decltype(std::declval<RosterReq>()._has_bits_);
  static const ::core::Jid& jid(const RosterReq* msg);
  static void set_has_jid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::core::Jid&
RosterReq::_Internal::jid(const RosterReq* msg) {
  return *msg->jid_;
}
void RosterReq::clear_jid() {
  if (jid_ != nullptr) jid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
RosterReq::RosterReq()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.RosterReq)
}
RosterReq::RosterReq(const RosterReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_jid()) {
    jid_ = new ::core::Jid(*from.jid_);
  } else {
    jid_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:im.RosterReq)
}

void RosterReq::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RosterReq_im_2eproto.base);
  jid_ = nullptr;
}

RosterReq::~RosterReq() {
  // @@protoc_insertion_point(destructor:im.RosterReq)
  SharedDtor();
}

void RosterReq::SharedDtor() {
  if (this != internal_default_instance()) delete jid_;
}

void RosterReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RosterReq& RosterReq::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RosterReq_im_2eproto.base);
  return *internal_default_instance();
}


void RosterReq::Clear() {
// @@protoc_insertion_point(message_clear_start:im.RosterReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(jid_ != nullptr);
    jid_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RosterReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid jid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_jid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RosterReq::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.RosterReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid jid = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::jid(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.RosterReq)
  return target;
}

size_t RosterReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.RosterReq)
  size_t total_size = 0;

  // required .core.Jid jid = 1;
  if (has_jid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *jid_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RosterReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RosterReq*>(
      &from));
}

void RosterReq::MergeFrom(const RosterReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.RosterReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_jid()) {
    _internal_mutable_jid()->::core::Jid::MergeFrom(from._internal_jid());
  }
}

void RosterReq::CopyFrom(const RosterReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.RosterReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_jid()) {
    if (!this->jid_->IsInitialized()) return false;
  }
  return true;
}

void RosterReq::InternalSwap(RosterReq* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(jid_, other->jid_);
}

std::string RosterReq::GetTypeName() const {
  return "im.RosterReq";
}


// ===================================================================

void RosterItem::InitAsDefaultInstance() {
  ::im::_RosterItem_default_instance_._instance.get_mutable()->jid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class RosterItem::_Internal {
 public:
  using HasBits = decltype(std::declval<RosterItem>()._has_bits_);
  static const ::core::Jid& jid(const RosterItem* msg);
  static void set_has_jid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_onlinestatus(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nickname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_department(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::core::Jid&
RosterItem::_Internal::jid(const RosterItem* msg) {
  return *msg->jid_;
}
void RosterItem::clear_jid() {
  if (jid_ != nullptr) jid_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
RosterItem::RosterItem()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.RosterItem)
}
RosterItem::RosterItem(const RosterItem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      grouptag_(from.grouptag_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  nickname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nickname()) {
    nickname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nickname_);
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  position_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_position()) {
    position_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.position_);
  }
  department_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_department()) {
    department_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.department_);
  }
  if (from._internal_has_jid()) {
    jid_ = new ::core::Jid(*from.jid_);
  } else {
    jid_ = nullptr;
  }
  onlinestatus_ = from.onlinestatus_;
  // @@protoc_insertion_point(copy_constructor:im.RosterItem)
}

void RosterItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RosterItem_im_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nickname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  position_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  department_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&jid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&onlinestatus_) -
      reinterpret_cast<char*>(&jid_)) + sizeof(onlinestatus_));
}

RosterItem::~RosterItem() {
  // @@protoc_insertion_point(destructor:im.RosterItem)
  SharedDtor();
}

void RosterItem::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nickname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  position_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  department_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete jid_;
}

void RosterItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RosterItem& RosterItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RosterItem_im_2eproto.base);
  return *internal_default_instance();
}


void RosterItem::Clear() {
// @@protoc_insertion_point(message_clear_start:im.RosterItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  grouptag_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nickname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      position_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      department_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(jid_ != nullptr);
      jid_->Clear();
    }
  }
  onlinestatus_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RosterItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid jid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_jid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 onlineStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_onlinestatus(&has_bits);
          onlinestatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string nickname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_nickname(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string position = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_position(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string department = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_department(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string groupTag = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_grouptag(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RosterItem::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.RosterItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid jid = 1;
  if (cached_has_bits & 0x00000020u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::jid(this), target, stream);
  }

  // required int32 onlineStatus = 2;
  if (cached_has_bits & 0x00000040u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_onlinestatus(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string nickname = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nickname(), target);
  }

  // optional string description = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  // optional string position = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_position(), target);
  }

  // optional string department = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_department(), target);
  }

  // repeated string groupTag = 8;
  for (int i = 0, n = this->_internal_grouptag_size(); i < n; i++) {
    const auto& s = this->_internal_grouptag(i);
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.RosterItem)
  return target;
}

size_t RosterItem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:im.RosterItem)
  size_t total_size = 0;

  if (has_jid()) {
    // required .core.Jid jid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *jid_);
  }

  if (has_onlinestatus()) {
    // required int32 onlineStatus = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_onlinestatus());
  }

  return total_size;
}
size_t RosterItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.RosterItem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000060) ^ 0x00000060) == 0) {  // All required fields are present.
    // required .core.Jid jid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *jid_);

    // required int32 onlineStatus = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_onlinestatus());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string groupTag = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(grouptag_.size());
  for (int i = 0, n = grouptag_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      grouptag_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string nickname = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nickname());
    }

    // optional string description = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string position = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_position());
    }

    // optional string department = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_department());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RosterItem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RosterItem*>(
      &from));
}

void RosterItem::MergeFrom(const RosterItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.RosterItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  grouptag_.MergeFrom(from.grouptag_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nickname_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nickname_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      position_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.position_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      department_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.department_);
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_jid()->::core::Jid::MergeFrom(from._internal_jid());
    }
    if (cached_has_bits & 0x00000040u) {
      onlinestatus_ = from.onlinestatus_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RosterItem::CopyFrom(const RosterItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.RosterItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosterItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000060) != 0x00000060) return false;
  if (has_jid()) {
    if (!this->jid_->IsInitialized()) return false;
  }
  return true;
}

void RosterItem::InternalSwap(RosterItem* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  grouptag_.InternalSwap(&other->grouptag_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nickname_.Swap(&other->nickname_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  position_.Swap(&other->position_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  department_.Swap(&other->department_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(jid_, other->jid_);
  swap(onlinestatus_, other->onlinestatus_);
}

std::string RosterItem::GetTypeName() const {
  return "im.RosterItem";
}


// ===================================================================

void RosterResp::InitAsDefaultInstance() {
}
class RosterResp::_Internal {
 public:
  using HasBits = decltype(std::declval<RosterResp>()._has_bits_);
};

RosterResp::RosterResp()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.RosterResp)
}
RosterResp::RosterResp(const RosterResp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      rosteritems_(from.rosteritems_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:im.RosterResp)
}

void RosterResp::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RosterResp_im_2eproto.base);
}

RosterResp::~RosterResp() {
  // @@protoc_insertion_point(destructor:im.RosterResp)
  SharedDtor();
}

void RosterResp::SharedDtor() {
}

void RosterResp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RosterResp& RosterResp::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RosterResp_im_2eproto.base);
  return *internal_default_instance();
}


void RosterResp::Clear() {
// @@protoc_insertion_point(message_clear_start:im.RosterResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  rosteritems_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RosterResp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .im.RosterItem rosterItems = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rosteritems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RosterResp::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.RosterResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .im.RosterItem rosterItems = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rosteritems_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_rosteritems(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.RosterResp)
  return target;
}

size_t RosterResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.RosterResp)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .im.RosterItem rosterItems = 1;
  total_size += 1UL * this->_internal_rosteritems_size();
  for (const auto& msg : this->rosteritems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RosterResp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RosterResp*>(
      &from));
}

void RosterResp::MergeFrom(const RosterResp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.RosterResp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  rosteritems_.MergeFrom(from.rosteritems_);
}

void RosterResp::CopyFrom(const RosterResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.RosterResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosterResp::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->rosteritems())) return false;
  return true;
}

void RosterResp::InternalSwap(RosterResp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rosteritems_.InternalSwap(&other->rosteritems_);
}

std::string RosterResp::GetTypeName() const {
  return "im.RosterResp";
}


// ===================================================================

void PresenceReq::InitAsDefaultInstance() {
  ::im::_PresenceReq_default_instance_._instance.get_mutable()->jid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class PresenceReq::_Internal {
 public:
  using HasBits = decltype(std::declval<PresenceReq>()._has_bits_);
  static const ::core::Jid& jid(const PresenceReq* msg);
  static void set_has_jid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::core::Jid&
PresenceReq::_Internal::jid(const PresenceReq* msg) {
  return *msg->jid_;
}
void PresenceReq::clear_jid() {
  if (jid_ != nullptr) jid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
PresenceReq::PresenceReq()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.PresenceReq)
}
PresenceReq::PresenceReq(const PresenceReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_jid()) {
    jid_ = new ::core::Jid(*from.jid_);
  } else {
    jid_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:im.PresenceReq)
}

void PresenceReq::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PresenceReq_im_2eproto.base);
  jid_ = nullptr;
}

PresenceReq::~PresenceReq() {
  // @@protoc_insertion_point(destructor:im.PresenceReq)
  SharedDtor();
}

void PresenceReq::SharedDtor() {
  if (this != internal_default_instance()) delete jid_;
}

void PresenceReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PresenceReq& PresenceReq::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PresenceReq_im_2eproto.base);
  return *internal_default_instance();
}


void PresenceReq::Clear() {
// @@protoc_insertion_point(message_clear_start:im.PresenceReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(jid_ != nullptr);
    jid_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PresenceReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid jid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_jid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PresenceReq::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.PresenceReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid jid = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::jid(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.PresenceReq)
  return target;
}

size_t PresenceReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.PresenceReq)
  size_t total_size = 0;

  // required .core.Jid jid = 1;
  if (has_jid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *jid_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PresenceReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PresenceReq*>(
      &from));
}

void PresenceReq::MergeFrom(const PresenceReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.PresenceReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_jid()) {
    _internal_mutable_jid()->::core::Jid::MergeFrom(from._internal_jid());
  }
}

void PresenceReq::CopyFrom(const PresenceReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.PresenceReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PresenceReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_jid()) {
    if (!this->jid_->IsInitialized()) return false;
  }
  return true;
}

void PresenceReq::InternalSwap(PresenceReq* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(jid_, other->jid_);
}

std::string PresenceReq::GetTypeName() const {
  return "im.PresenceReq";
}


// ===================================================================

void PresenceResp::InitAsDefaultInstance() {
}
class PresenceResp::_Internal {
 public:
  using HasBits = decltype(std::declval<PresenceResp>()._has_bits_);
};

void PresenceResp::clear_jids() {
  jids_.Clear();
}
PresenceResp::PresenceResp()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.PresenceResp)
}
PresenceResp::PresenceResp(const PresenceResp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      jids_(from.jids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:im.PresenceResp)
}

void PresenceResp::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PresenceResp_im_2eproto.base);
}

PresenceResp::~PresenceResp() {
  // @@protoc_insertion_point(destructor:im.PresenceResp)
  SharedDtor();
}

void PresenceResp::SharedDtor() {
}

void PresenceResp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PresenceResp& PresenceResp::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PresenceResp_im_2eproto.base);
  return *internal_default_instance();
}


void PresenceResp::Clear() {
// @@protoc_insertion_point(message_clear_start:im.PresenceResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  jids_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PresenceResp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .core.Jid jids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_jids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PresenceResp::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.PresenceResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .core.Jid jids = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_jids_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_jids(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.PresenceResp)
  return target;
}

size_t PresenceResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.PresenceResp)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .core.Jid jids = 1;
  total_size += 1UL * this->_internal_jids_size();
  for (const auto& msg : this->jids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PresenceResp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PresenceResp*>(
      &from));
}

void PresenceResp::MergeFrom(const PresenceResp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.PresenceResp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  jids_.MergeFrom(from.jids_);
}

void PresenceResp::CopyFrom(const PresenceResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.PresenceResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PresenceResp::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->jids())) return false;
  return true;
}

void PresenceResp::InternalSwap(PresenceResp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  jids_.InternalSwap(&other->jids_);
}

std::string PresenceResp::GetTypeName() const {
  return "im.PresenceResp";
}


// ===================================================================

void MessageElement::InitAsDefaultInstance() {
}
class MessageElement::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageElement>()._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MessageElement::MessageElement()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.MessageElement)
}
MessageElement::MessageElement(const MessageElement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  kind_ = from.kind_;
  // @@protoc_insertion_point(copy_constructor:im.MessageElement)
}

void MessageElement::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MessageElement_im_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kind_ = 0;
}

MessageElement::~MessageElement() {
  // @@protoc_insertion_point(destructor:im.MessageElement)
  SharedDtor();
}

void MessageElement::SharedDtor() {
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MessageElement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageElement& MessageElement::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MessageElement_im_2eproto.base);
  return *internal_default_instance();
}


void MessageElement::Clear() {
// @@protoc_insertion_point(message_clear_start:im.MessageElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmptyNoArena();
  }
  kind_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* MessageElement::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .im.EnumMessageElement kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::im::EnumMessageElement_IsValid(val))) {
            _internal_set_kind(static_cast<::im::EnumMessageElement>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageElement::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.MessageElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .im.EnumMessageElement kind = 1;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // required bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.MessageElement)
  return target;
}

size_t MessageElement::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:im.MessageElement)
  size_t total_size = 0;

  if (has_data()) {
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (has_kind()) {
    // required .im.EnumMessageElement kind = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return total_size;
}
size_t MessageElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.MessageElement)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required .im.EnumMessageElement kind = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageElement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MessageElement*>(
      &from));
}

void MessageElement::MergeFrom(const MessageElement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.MessageElement)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      kind_ = from.kind_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MessageElement::CopyFrom(const MessageElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.MessageElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageElement::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void MessageElement::InternalSwap(MessageElement* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(kind_, other->kind_);
}

std::string MessageElement::GetTypeName() const {
  return "im.MessageElement";
}


// ===================================================================

void ChatMessage::InitAsDefaultInstance() {
  ::im::_ChatMessage_default_instance_._instance.get_mutable()->fromjid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
  ::im::_ChatMessage_default_instance_._instance.get_mutable()->tojid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class ChatMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ChatMessage>()._has_bits_);
  static const ::core::Jid& fromjid(const ChatMessage* msg);
  static void set_has_fromjid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::core::Jid& tojid(const ChatMessage* msg);
  static void set_has_tojid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::core::Jid&
ChatMessage::_Internal::fromjid(const ChatMessage* msg) {
  return *msg->fromjid_;
}
const ::core::Jid&
ChatMessage::_Internal::tojid(const ChatMessage* msg) {
  return *msg->tojid_;
}
void ChatMessage::clear_fromjid() {
  if (fromjid_ != nullptr) fromjid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void ChatMessage::clear_tojid() {
  if (tojid_ != nullptr) tojid_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
ChatMessage::ChatMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.ChatMessage)
}
ChatMessage::ChatMessage(const ChatMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      body_(from.body_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_fromjid()) {
    fromjid_ = new ::core::Jid(*from.fromjid_);
  } else {
    fromjid_ = nullptr;
  }
  if (from._internal_has_tojid()) {
    tojid_ = new ::core::Jid(*from.tojid_);
  } else {
    tojid_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:im.ChatMessage)
}

void ChatMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ChatMessage_im_2eproto.base);
  ::memset(&fromjid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tojid_) -
      reinterpret_cast<char*>(&fromjid_)) + sizeof(tojid_));
}

ChatMessage::~ChatMessage() {
  // @@protoc_insertion_point(destructor:im.ChatMessage)
  SharedDtor();
}

void ChatMessage::SharedDtor() {
  if (this != internal_default_instance()) delete fromjid_;
  if (this != internal_default_instance()) delete tojid_;
}

void ChatMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChatMessage& ChatMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ChatMessage_im_2eproto.base);
  return *internal_default_instance();
}


void ChatMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:im.ChatMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  body_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(fromjid_ != nullptr);
      fromjid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(tojid_ != nullptr);
      tojid_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ChatMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid fromJid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fromjid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .core.Jid toJid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tojid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .im.MessageElement body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_body(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ChatMessage::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.ChatMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid fromJid = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::fromjid(this), target, stream);
  }

  // required .core.Jid toJid = 2;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::tojid(this), target, stream);
  }

  // repeated .im.MessageElement body = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_body_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(3, this->_internal_body(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.ChatMessage)
  return target;
}

size_t ChatMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:im.ChatMessage)
  size_t total_size = 0;

  if (has_fromjid()) {
    // required .core.Jid fromJid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fromjid_);
  }

  if (has_tojid()) {
    // required .core.Jid toJid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tojid_);
  }

  return total_size;
}
size_t ChatMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.ChatMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .core.Jid fromJid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fromjid_);

    // required .core.Jid toJid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tojid_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .im.MessageElement body = 3;
  total_size += 1UL * this->_internal_body_size();
  for (const auto& msg : this->body_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChatMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ChatMessage*>(
      &from));
}

void ChatMessage::MergeFrom(const ChatMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.ChatMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  body_.MergeFrom(from.body_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_fromjid()->::core::Jid::MergeFrom(from._internal_fromjid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_tojid()->::core::Jid::MergeFrom(from._internal_tojid());
    }
  }
}

void ChatMessage::CopyFrom(const ChatMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.ChatMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->body())) return false;
  if (has_fromjid()) {
    if (!this->fromjid_->IsInitialized()) return false;
  }
  if (has_tojid()) {
    if (!this->tojid_->IsInitialized()) return false;
  }
  return true;
}

void ChatMessage::InternalSwap(ChatMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  body_.InternalSwap(&other->body_);
  swap(fromjid_, other->fromjid_);
  swap(tojid_, other->tojid_);
}

std::string ChatMessage::GetTypeName() const {
  return "im.ChatMessage";
}


// ===================================================================

void AlertMessage::InitAsDefaultInstance() {
}
class AlertMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AlertMessage>()._has_bits_);
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AlertMessage::AlertMessage()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:im.AlertMessage)
}
AlertMessage::AlertMessage(const AlertMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_body()) {
    body_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.body_);
  }
  // @@protoc_insertion_point(copy_constructor:im.AlertMessage)
}

void AlertMessage::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AlertMessage_im_2eproto.base);
  body_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AlertMessage::~AlertMessage() {
  // @@protoc_insertion_point(destructor:im.AlertMessage)
  SharedDtor();
}

void AlertMessage::SharedDtor() {
  body_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AlertMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AlertMessage& AlertMessage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AlertMessage_im_2eproto.base);
  return *internal_default_instance();
}


void AlertMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:im.AlertMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    body_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* AlertMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_body(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AlertMessage::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:im.AlertMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:im.AlertMessage)
  return target;
}

size_t AlertMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:im.AlertMessage)
  size_t total_size = 0;

  // required string body = 3;
  if (has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_body());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AlertMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AlertMessage*>(
      &from));
}

void AlertMessage::MergeFrom(const AlertMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:im.AlertMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_body()) {
    _has_bits_[0] |= 0x00000001u;
    body_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.body_);
  }
}

void AlertMessage::CopyFrom(const AlertMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:im.AlertMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlertMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void AlertMessage::InternalSwap(AlertMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  body_.Swap(&other->body_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string AlertMessage::GetTypeName() const {
  return "im.AlertMessage";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace im
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::im::Presence* Arena::CreateMaybeMessage< ::im::Presence >(Arena* arena) {
  return Arena::CreateInternal< ::im::Presence >(arena);
}
template<> PROTOBUF_NOINLINE ::im::RosterReq* Arena::CreateMaybeMessage< ::im::RosterReq >(Arena* arena) {
  return Arena::CreateInternal< ::im::RosterReq >(arena);
}
template<> PROTOBUF_NOINLINE ::im::RosterItem* Arena::CreateMaybeMessage< ::im::RosterItem >(Arena* arena) {
  return Arena::CreateInternal< ::im::RosterItem >(arena);
}
template<> PROTOBUF_NOINLINE ::im::RosterResp* Arena::CreateMaybeMessage< ::im::RosterResp >(Arena* arena) {
  return Arena::CreateInternal< ::im::RosterResp >(arena);
}
template<> PROTOBUF_NOINLINE ::im::PresenceReq* Arena::CreateMaybeMessage< ::im::PresenceReq >(Arena* arena) {
  return Arena::CreateInternal< ::im::PresenceReq >(arena);
}
template<> PROTOBUF_NOINLINE ::im::PresenceResp* Arena::CreateMaybeMessage< ::im::PresenceResp >(Arena* arena) {
  return Arena::CreateInternal< ::im::PresenceResp >(arena);
}
template<> PROTOBUF_NOINLINE ::im::MessageElement* Arena::CreateMaybeMessage< ::im::MessageElement >(Arena* arena) {
  return Arena::CreateInternal< ::im::MessageElement >(arena);
}
template<> PROTOBUF_NOINLINE ::im::ChatMessage* Arena::CreateMaybeMessage< ::im::ChatMessage >(Arena* arena) {
  return Arena::CreateInternal< ::im::ChatMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::im::AlertMessage* Arena::CreateMaybeMessage< ::im::AlertMessage >(Arena* arena) {
  return Arena::CreateInternal< ::im::AlertMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
