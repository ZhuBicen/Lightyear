// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#ifndef PROTOBUF_core_2eproto__INCLUDED
#define PROTOBUF_core_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace core {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_core_2eproto();
void protobuf_AssignDesc_core_2eproto();
void protobuf_ShutdownFile_core_2eproto();

class Jid;
class AuthenticationReq;
class Response;
class AuthenticationResp;
class Heartbeat;
class HeartbeatAck;

enum AuthenticationReq_ResourceType {
  AuthenticationReq_ResourceType_WINPC = 0,
  AuthenticationReq_ResourceType_ANDROID = 1,
  AuthenticationReq_ResourceType_IPHONE = 2,
  AuthenticationReq_ResourceType_IPAD = 3
};
bool AuthenticationReq_ResourceType_IsValid(int value);
const AuthenticationReq_ResourceType AuthenticationReq_ResourceType_ResourceType_MIN = AuthenticationReq_ResourceType_WINPC;
const AuthenticationReq_ResourceType AuthenticationReq_ResourceType_ResourceType_MAX = AuthenticationReq_ResourceType_IPAD;
const int AuthenticationReq_ResourceType_ResourceType_ARRAYSIZE = AuthenticationReq_ResourceType_ResourceType_MAX + 1;

// ===================================================================

class Jid : public ::google::protobuf::MessageLite {
 public:
  Jid();
  virtual ~Jid();

  Jid(const Jid& from);

  inline Jid& operator=(const Jid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Jid& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Jid* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Jid* other);

  // implements Message ----------------------------------------------

  Jid* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Jid& from);
  void MergeFrom(const Jid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:core.Jid)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* domain_;
  ::std::string* resource_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static Jid* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationReq : public ::google::protobuf::MessageLite {
 public:
  AuthenticationReq();
  virtual ~AuthenticationReq();

  AuthenticationReq(const AuthenticationReq& from);

  inline AuthenticationReq& operator=(const AuthenticationReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticationReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticationReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticationReq* other);

  // implements Message ----------------------------------------------

  AuthenticationReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticationReq& from);
  void MergeFrom(const AuthenticationReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AuthenticationReq_ResourceType ResourceType;
  static const ResourceType WINPC = AuthenticationReq_ResourceType_WINPC;
  static const ResourceType ANDROID = AuthenticationReq_ResourceType_ANDROID;
  static const ResourceType IPHONE = AuthenticationReq_ResourceType_IPHONE;
  static const ResourceType IPAD = AuthenticationReq_ResourceType_IPAD;
  static inline bool ResourceType_IsValid(int value) {
    return AuthenticationReq_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    AuthenticationReq_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    AuthenticationReq_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    AuthenticationReq_ResourceType_ResourceType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .core.Jid jid = 1;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 1;
  inline const ::core::Jid& jid() const;
  inline ::core::Jid* mutable_jid();
  inline ::core::Jid* release_jid();
  inline void set_allocated_jid(::core::Jid* jid);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .core.AuthenticationReq.ResourceType resourceType = 3 [default = WINPC];
  inline bool has_resourcetype() const;
  inline void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 3;
  inline ::core::AuthenticationReq_ResourceType resourcetype() const;
  inline void set_resourcetype(::core::AuthenticationReq_ResourceType value);

  // optional string resourceName = 4;
  inline bool has_resourcename() const;
  inline void clear_resourcename();
  static const int kResourceNameFieldNumber = 4;
  inline const ::std::string& resourcename() const;
  inline void set_resourcename(const ::std::string& value);
  inline void set_resourcename(const char* value);
  inline void set_resourcename(const char* value, size_t size);
  inline ::std::string* mutable_resourcename();
  inline ::std::string* release_resourcename();
  inline void set_allocated_resourcename(::std::string* resourcename);

  // @@protoc_insertion_point(class_scope:core.AuthenticationReq)
 private:
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_resourcetype();
  inline void clear_has_resourcetype();
  inline void set_has_resourcename();
  inline void clear_has_resourcename();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* jid_;
  ::std::string* password_;
  ::std::string* resourcename_;
  int resourcetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static AuthenticationReq* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::MessageLite {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Response& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string cause = 2;
  inline bool has_cause() const;
  inline void clear_cause();
  static const int kCauseFieldNumber = 2;
  inline const ::std::string& cause() const;
  inline void set_cause(const ::std::string& value);
  inline void set_cause(const char* value);
  inline void set_cause(const char* value, size_t size);
  inline ::std::string* mutable_cause();
  inline ::std::string* release_cause();
  inline void set_allocated_cause(::std::string* cause);

  // @@protoc_insertion_point(class_scope:core.Response)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_cause();
  inline void clear_has_cause();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cause_;
  ::google::protobuf::int32 status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationResp : public ::google::protobuf::MessageLite {
 public:
  AuthenticationResp();
  virtual ~AuthenticationResp();

  AuthenticationResp(const AuthenticationResp& from);

  inline AuthenticationResp& operator=(const AuthenticationResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticationResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticationResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticationResp* other);

  // implements Message ----------------------------------------------

  AuthenticationResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticationResp& from);
  void MergeFrom(const AuthenticationResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Response resp = 1;
  inline bool has_resp() const;
  inline void clear_resp();
  static const int kRespFieldNumber = 1;
  inline const ::core::Response& resp() const;
  inline ::core::Response* mutable_resp();
  inline ::core::Response* release_resp();
  inline void set_allocated_resp(::core::Response* resp);

  // optional .core.Jid fullJid = 3;
  inline bool has_fulljid() const;
  inline void clear_fulljid();
  static const int kFullJidFieldNumber = 3;
  inline const ::core::Jid& fulljid() const;
  inline ::core::Jid* mutable_fulljid();
  inline ::core::Jid* release_fulljid();
  inline void set_allocated_fulljid(::core::Jid* fulljid);

  // @@protoc_insertion_point(class_scope:core.AuthenticationResp)
 private:
  inline void set_has_resp();
  inline void clear_has_resp();
  inline void set_has_fulljid();
  inline void clear_has_fulljid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Response* resp_;
  ::core::Jid* fulljid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static AuthenticationResp* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::MessageLite {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Heartbeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Heartbeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:core.Heartbeat)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatAck : public ::google::protobuf::MessageLite {
 public:
  HeartbeatAck();
  virtual ~HeartbeatAck();

  HeartbeatAck(const HeartbeatAck& from);

  inline HeartbeatAck& operator=(const HeartbeatAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HeartbeatAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartbeatAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartbeatAck* other);

  // implements Message ----------------------------------------------

  HeartbeatAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartbeatAck& from);
  void MergeFrom(const HeartbeatAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .core.Jid fromJid = 1;
  inline bool has_fromjid() const;
  inline void clear_fromjid();
  static const int kFromJidFieldNumber = 1;
  inline const ::core::Jid& fromjid() const;
  inline ::core::Jid* mutable_fromjid();
  inline ::core::Jid* release_fromjid();
  inline void set_allocated_fromjid(::core::Jid* fromjid);

  // @@protoc_insertion_point(class_scope:core.HeartbeatAck)
 private:
  inline void set_has_fromjid();
  inline void clear_has_fromjid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::core::Jid* fromjid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_core_2eproto();
  #endif
  friend void protobuf_AssignDesc_core_2eproto();
  friend void protobuf_ShutdownFile_core_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatAck* default_instance_;
};
// ===================================================================


// ===================================================================

// Jid

// required string id = 1;
inline bool Jid::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Jid::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Jid::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Jid::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Jid::id() const {
  // @@protoc_insertion_point(field_get:core.Jid.id)
  return *id_;
}
inline void Jid::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:core.Jid.id)
}
inline void Jid::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.Jid.id)
}
inline void Jid::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.Jid.id)
}
inline ::std::string* Jid::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.Jid.id)
  return id_;
}
inline ::std::string* Jid::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Jid::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.Jid.id)
}

// optional string domain = 2;
inline bool Jid::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Jid::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Jid::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Jid::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& Jid::domain() const {
  // @@protoc_insertion_point(field_get:core.Jid.domain)
  return *domain_;
}
inline void Jid::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:core.Jid.domain)
}
inline void Jid::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.Jid.domain)
}
inline void Jid::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.Jid.domain)
}
inline ::std::string* Jid::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.Jid.domain)
  return domain_;
}
inline ::std::string* Jid::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Jid::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.Jid.domain)
}

// optional string resource = 3;
inline bool Jid::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Jid::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Jid::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Jid::clear_resource() {
  if (resource_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& Jid::resource() const {
  // @@protoc_insertion_point(field_get:core.Jid.resource)
  return *resource_;
}
inline void Jid::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
  // @@protoc_insertion_point(field_set:core.Jid.resource)
}
inline void Jid::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.Jid.resource)
}
inline void Jid::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.Jid.resource)
}
inline ::std::string* Jid::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.Jid.resource)
  return resource_;
}
inline ::std::string* Jid::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Jid::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.Jid.resource)
}

// -------------------------------------------------------------------

// AuthenticationReq

// required .core.Jid jid = 1;
inline bool AuthenticationReq::has_jid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationReq::set_has_jid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationReq::clear_has_jid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationReq::clear_jid() {
  if (jid_ != NULL) jid_->::core::Jid::Clear();
  clear_has_jid();
}
inline const ::core::Jid& AuthenticationReq::jid() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationReq.jid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return jid_ != NULL ? *jid_ : *default_instance().jid_;
#else
  return jid_ != NULL ? *jid_ : *default_instance_->jid_;
#endif
}
inline ::core::Jid* AuthenticationReq::mutable_jid() {
  set_has_jid();
  if (jid_ == NULL) jid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:core.AuthenticationReq.jid)
  return jid_;
}
inline ::core::Jid* AuthenticationReq::release_jid() {
  clear_has_jid();
  ::core::Jid* temp = jid_;
  jid_ = NULL;
  return temp;
}
inline void AuthenticationReq::set_allocated_jid(::core::Jid* jid) {
  delete jid_;
  jid_ = jid;
  if (jid) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  // @@protoc_insertion_point(field_set_allocated:core.AuthenticationReq.jid)
}

// optional string password = 2;
inline bool AuthenticationReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AuthenticationReq::password() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationReq.password)
  return *password_;
}
inline void AuthenticationReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:core.AuthenticationReq.password)
}
inline void AuthenticationReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.AuthenticationReq.password)
}
inline void AuthenticationReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.AuthenticationReq.password)
}
inline ::std::string* AuthenticationReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.AuthenticationReq.password)
  return password_;
}
inline ::std::string* AuthenticationReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthenticationReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.AuthenticationReq.password)
}

// optional .core.AuthenticationReq.ResourceType resourceType = 3 [default = WINPC];
inline bool AuthenticationReq::has_resourcetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticationReq::set_has_resourcetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticationReq::clear_has_resourcetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticationReq::clear_resourcetype() {
  resourcetype_ = 0;
  clear_has_resourcetype();
}
inline ::core::AuthenticationReq_ResourceType AuthenticationReq::resourcetype() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationReq.resourceType)
  return static_cast< ::core::AuthenticationReq_ResourceType >(resourcetype_);
}
inline void AuthenticationReq::set_resourcetype(::core::AuthenticationReq_ResourceType value) {
  assert(::core::AuthenticationReq_ResourceType_IsValid(value));
  set_has_resourcetype();
  resourcetype_ = value;
  // @@protoc_insertion_point(field_set:core.AuthenticationReq.resourceType)
}

// optional string resourceName = 4;
inline bool AuthenticationReq::has_resourcename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthenticationReq::set_has_resourcename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthenticationReq::clear_has_resourcename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthenticationReq::clear_resourcename() {
  if (resourcename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourcename_->clear();
  }
  clear_has_resourcename();
}
inline const ::std::string& AuthenticationReq::resourcename() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationReq.resourceName)
  return *resourcename_;
}
inline void AuthenticationReq::set_resourcename(const ::std::string& value) {
  set_has_resourcename();
  if (resourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourcename_ = new ::std::string;
  }
  resourcename_->assign(value);
  // @@protoc_insertion_point(field_set:core.AuthenticationReq.resourceName)
}
inline void AuthenticationReq::set_resourcename(const char* value) {
  set_has_resourcename();
  if (resourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourcename_ = new ::std::string;
  }
  resourcename_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.AuthenticationReq.resourceName)
}
inline void AuthenticationReq::set_resourcename(const char* value, size_t size) {
  set_has_resourcename();
  if (resourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourcename_ = new ::std::string;
  }
  resourcename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.AuthenticationReq.resourceName)
}
inline ::std::string* AuthenticationReq::mutable_resourcename() {
  set_has_resourcename();
  if (resourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resourcename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.AuthenticationReq.resourceName)
  return resourcename_;
}
inline ::std::string* AuthenticationReq::release_resourcename() {
  clear_has_resourcename();
  if (resourcename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resourcename_;
    resourcename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthenticationReq::set_allocated_resourcename(::std::string* resourcename) {
  if (resourcename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resourcename_;
  }
  if (resourcename) {
    set_has_resourcename();
    resourcename_ = resourcename;
  } else {
    clear_has_resourcename();
    resourcename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.AuthenticationReq.resourceName)
}

// -------------------------------------------------------------------

// Response

// required int32 status = 1;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Response::status() const {
  // @@protoc_insertion_point(field_get:core.Response.status)
  return status_;
}
inline void Response::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:core.Response.status)
}

// optional string cause = 2;
inline bool Response::has_cause() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_cause() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_cause() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_cause() {
  if (cause_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cause_->clear();
  }
  clear_has_cause();
}
inline const ::std::string& Response::cause() const {
  // @@protoc_insertion_point(field_get:core.Response.cause)
  return *cause_;
}
inline void Response::set_cause(const ::std::string& value) {
  set_has_cause();
  if (cause_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cause_ = new ::std::string;
  }
  cause_->assign(value);
  // @@protoc_insertion_point(field_set:core.Response.cause)
}
inline void Response::set_cause(const char* value) {
  set_has_cause();
  if (cause_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cause_ = new ::std::string;
  }
  cause_->assign(value);
  // @@protoc_insertion_point(field_set_char:core.Response.cause)
}
inline void Response::set_cause(const char* value, size_t size) {
  set_has_cause();
  if (cause_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cause_ = new ::std::string;
  }
  cause_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:core.Response.cause)
}
inline ::std::string* Response::mutable_cause() {
  set_has_cause();
  if (cause_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cause_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:core.Response.cause)
  return cause_;
}
inline ::std::string* Response::release_cause() {
  clear_has_cause();
  if (cause_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cause_;
    cause_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_cause(::std::string* cause) {
  if (cause_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cause_;
  }
  if (cause) {
    set_has_cause();
    cause_ = cause;
  } else {
    clear_has_cause();
    cause_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:core.Response.cause)
}

// -------------------------------------------------------------------

// AuthenticationResp

// required .core.Response resp = 1;
inline bool AuthenticationResp::has_resp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationResp::set_has_resp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationResp::clear_has_resp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationResp::clear_resp() {
  if (resp_ != NULL) resp_->::core::Response::Clear();
  clear_has_resp();
}
inline const ::core::Response& AuthenticationResp::resp() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationResp.resp)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resp_ != NULL ? *resp_ : *default_instance().resp_;
#else
  return resp_ != NULL ? *resp_ : *default_instance_->resp_;
#endif
}
inline ::core::Response* AuthenticationResp::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) resp_ = new ::core::Response;
  // @@protoc_insertion_point(field_mutable:core.AuthenticationResp.resp)
  return resp_;
}
inline ::core::Response* AuthenticationResp::release_resp() {
  clear_has_resp();
  ::core::Response* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void AuthenticationResp::set_allocated_resp(::core::Response* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    set_has_resp();
  } else {
    clear_has_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:core.AuthenticationResp.resp)
}

// optional .core.Jid fullJid = 3;
inline bool AuthenticationResp::has_fulljid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationResp::set_has_fulljid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationResp::clear_has_fulljid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationResp::clear_fulljid() {
  if (fulljid_ != NULL) fulljid_->::core::Jid::Clear();
  clear_has_fulljid();
}
inline const ::core::Jid& AuthenticationResp::fulljid() const {
  // @@protoc_insertion_point(field_get:core.AuthenticationResp.fullJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fulljid_ != NULL ? *fulljid_ : *default_instance().fulljid_;
#else
  return fulljid_ != NULL ? *fulljid_ : *default_instance_->fulljid_;
#endif
}
inline ::core::Jid* AuthenticationResp::mutable_fulljid() {
  set_has_fulljid();
  if (fulljid_ == NULL) fulljid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:core.AuthenticationResp.fullJid)
  return fulljid_;
}
inline ::core::Jid* AuthenticationResp::release_fulljid() {
  clear_has_fulljid();
  ::core::Jid* temp = fulljid_;
  fulljid_ = NULL;
  return temp;
}
inline void AuthenticationResp::set_allocated_fulljid(::core::Jid* fulljid) {
  delete fulljid_;
  fulljid_ = fulljid;
  if (fulljid) {
    set_has_fulljid();
  } else {
    clear_has_fulljid();
  }
  // @@protoc_insertion_point(field_set_allocated:core.AuthenticationResp.fullJid)
}

// -------------------------------------------------------------------

// Heartbeat

// -------------------------------------------------------------------

// HeartbeatAck

// required .core.Jid fromJid = 1;
inline bool HeartbeatAck::has_fromjid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatAck::set_has_fromjid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatAck::clear_has_fromjid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatAck::clear_fromjid() {
  if (fromjid_ != NULL) fromjid_->::core::Jid::Clear();
  clear_has_fromjid();
}
inline const ::core::Jid& HeartbeatAck::fromjid() const {
  // @@protoc_insertion_point(field_get:core.HeartbeatAck.fromJid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fromjid_ != NULL ? *fromjid_ : *default_instance().fromjid_;
#else
  return fromjid_ != NULL ? *fromjid_ : *default_instance_->fromjid_;
#endif
}
inline ::core::Jid* HeartbeatAck::mutable_fromjid() {
  set_has_fromjid();
  if (fromjid_ == NULL) fromjid_ = new ::core::Jid;
  // @@protoc_insertion_point(field_mutable:core.HeartbeatAck.fromJid)
  return fromjid_;
}
inline ::core::Jid* HeartbeatAck::release_fromjid() {
  clear_has_fromjid();
  ::core::Jid* temp = fromjid_;
  fromjid_ = NULL;
  return temp;
}
inline void HeartbeatAck::set_allocated_fromjid(::core::Jid* fromjid) {
  delete fromjid_;
  fromjid_ = fromjid;
  if (fromjid) {
    set_has_fromjid();
  } else {
    clear_has_fromjid();
  }
  // @@protoc_insertion_point(field_set_allocated:core.HeartbeatAck.fromJid)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace core

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_core_2eproto__INCLUDED
