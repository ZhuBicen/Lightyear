// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#include "core.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_core_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Jid_core_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_core_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Response_core_2eproto;
namespace core {
class JidDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Jid> _instance;
} _Jid_default_instance_;
class AuthenticationReqDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AuthenticationReq> _instance;
} _AuthenticationReq_default_instance_;
class ResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Response> _instance;
} _Response_default_instance_;
class AuthenticationRespDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AuthenticationResp> _instance;
} _AuthenticationResp_default_instance_;
class HeartbeatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Heartbeat> _instance;
} _Heartbeat_default_instance_;
class HeartbeatAckDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HeartbeatAck> _instance;
} _HeartbeatAck_default_instance_;
}  // namespace core
static void InitDefaultsscc_info_AuthenticationReq_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_AuthenticationReq_default_instance_;
    new (ptr) ::core::AuthenticationReq();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::AuthenticationReq::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AuthenticationReq_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AuthenticationReq_core_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_AuthenticationResp_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_AuthenticationResp_default_instance_;
    new (ptr) ::core::AuthenticationResp();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::AuthenticationResp::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_AuthenticationResp_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_AuthenticationResp_core_2eproto}, {
      &scc_info_Response_core_2eproto.base,
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_Heartbeat_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_Heartbeat_default_instance_;
    new (ptr) ::core::Heartbeat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::Heartbeat::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Heartbeat_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Heartbeat_core_2eproto}, {}};

static void InitDefaultsscc_info_HeartbeatAck_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_HeartbeatAck_default_instance_;
    new (ptr) ::core::HeartbeatAck();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::HeartbeatAck::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_HeartbeatAck_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_HeartbeatAck_core_2eproto}, {
      &scc_info_Jid_core_2eproto.base,}};

static void InitDefaultsscc_info_Jid_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_Jid_default_instance_;
    new (ptr) ::core::Jid();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::Jid::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Jid_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Jid_core_2eproto}, {}};

static void InitDefaultsscc_info_Response_core_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::core::_Response_default_instance_;
    new (ptr) ::core::Response();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::core::Response::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Response_core_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Response_core_2eproto}, {}};

namespace core {
bool AuthenticationReq_ResourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuthenticationReq_ResourceType_strings[4] = {};

static const char AuthenticationReq_ResourceType_names[] =
  "ANDROID"
  "IPAD"
  "IPHONE"
  "WINPC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuthenticationReq_ResourceType_entries[] = {
  { {AuthenticationReq_ResourceType_names + 0, 7}, 1 },
  { {AuthenticationReq_ResourceType_names + 7, 4}, 3 },
  { {AuthenticationReq_ResourceType_names + 11, 6}, 2 },
  { {AuthenticationReq_ResourceType_names + 17, 5}, 0 },
};

static const int AuthenticationReq_ResourceType_entries_by_number[] = {
  3, // 0 -> WINPC
  0, // 1 -> ANDROID
  2, // 2 -> IPHONE
  1, // 3 -> IPAD
};

const std::string& AuthenticationReq_ResourceType_Name(
    AuthenticationReq_ResourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuthenticationReq_ResourceType_entries,
          AuthenticationReq_ResourceType_entries_by_number,
          4, AuthenticationReq_ResourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuthenticationReq_ResourceType_entries,
      AuthenticationReq_ResourceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuthenticationReq_ResourceType_strings[idx].get();
}
bool AuthenticationReq_ResourceType_Parse(
    const std::string& name, AuthenticationReq_ResourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuthenticationReq_ResourceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AuthenticationReq_ResourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AuthenticationReq_ResourceType AuthenticationReq::WINPC;
constexpr AuthenticationReq_ResourceType AuthenticationReq::ANDROID;
constexpr AuthenticationReq_ResourceType AuthenticationReq::IPHONE;
constexpr AuthenticationReq_ResourceType AuthenticationReq::IPAD;
constexpr AuthenticationReq_ResourceType AuthenticationReq::ResourceType_MIN;
constexpr AuthenticationReq_ResourceType AuthenticationReq::ResourceType_MAX;
constexpr int AuthenticationReq::ResourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Jid::InitAsDefaultInstance() {
}
class Jid::_Internal {
 public:
  using HasBits = decltype(std::declval<Jid>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Jid::Jid()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.Jid)
}
Jid::Jid(const Jid& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_domain()) {
    domain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.domain_);
  }
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_resource()) {
    resource_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.resource_);
  }
  // @@protoc_insertion_point(copy_constructor:core.Jid)
}

void Jid::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Jid_core_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Jid::~Jid() {
  // @@protoc_insertion_point(destructor:core.Jid)
  SharedDtor();
}

void Jid::SharedDtor() {
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Jid::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Jid& Jid::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Jid_core_2eproto.base);
  return *internal_default_instance();
}


void Jid::Clear() {
// @@protoc_insertion_point(message_clear_start:core.Jid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      domain_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      resource_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Jid::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_domain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string resource = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_resource(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Jid::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.Jid)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string domain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain(), target);
  }

  // optional string resource = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_resource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.Jid)
  return target;
}

size_t Jid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.Jid)
  size_t total_size = 0;

  // required string id = 1;
  if (has_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string domain = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain());
    }

    // optional string resource = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Jid::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Jid*>(
      &from));
}

void Jid::MergeFrom(const Jid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.Jid)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      domain_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.domain_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      resource_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.resource_);
    }
  }
}

void Jid::CopyFrom(const Jid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.Jid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Jid::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Jid::InternalSwap(Jid* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  domain_.Swap(&other->domain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string Jid::GetTypeName() const {
  return "core.Jid";
}


// ===================================================================

void AuthenticationReq::InitAsDefaultInstance() {
  ::core::_AuthenticationReq_default_instance_._instance.get_mutable()->jid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class AuthenticationReq::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticationReq>()._has_bits_);
  static const ::core::Jid& jid(const AuthenticationReq* msg);
  static void set_has_jid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resourcetype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_resourcename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::core::Jid&
AuthenticationReq::_Internal::jid(const AuthenticationReq* msg) {
  return *msg->jid_;
}
AuthenticationReq::AuthenticationReq()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.AuthenticationReq)
}
AuthenticationReq::AuthenticationReq(const AuthenticationReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_password()) {
    password_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
  resourcename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_resourcename()) {
    resourcename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.resourcename_);
  }
  if (from._internal_has_jid()) {
    jid_ = new ::core::Jid(*from.jid_);
  } else {
    jid_ = nullptr;
  }
  resourcetype_ = from.resourcetype_;
  // @@protoc_insertion_point(copy_constructor:core.AuthenticationReq)
}

void AuthenticationReq::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AuthenticationReq_core_2eproto.base);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resourcename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&jid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&resourcetype_) -
      reinterpret_cast<char*>(&jid_)) + sizeof(resourcetype_));
}

AuthenticationReq::~AuthenticationReq() {
  // @@protoc_insertion_point(destructor:core.AuthenticationReq)
  SharedDtor();
}

void AuthenticationReq::SharedDtor() {
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resourcename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete jid_;
}

void AuthenticationReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AuthenticationReq& AuthenticationReq::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AuthenticationReq_core_2eproto.base);
  return *internal_default_instance();
}


void AuthenticationReq::Clear() {
// @@protoc_insertion_point(message_clear_start:core.AuthenticationReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      password_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      resourcename_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(jid_ != nullptr);
      jid_->Clear();
    }
  }
  resourcetype_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* AuthenticationReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid jid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_jid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_password(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .core.AuthenticationReq.ResourceType resourceType = 3 [default = WINPC];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::core::AuthenticationReq_ResourceType_IsValid(val))) {
            _internal_set_resourcetype(static_cast<::core::AuthenticationReq_ResourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string resourceName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_resourcename(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AuthenticationReq::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.AuthenticationReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid jid = 1;
  if (cached_has_bits & 0x00000004u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::jid(this), target, stream);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  // optional .core.AuthenticationReq.ResourceType resourceType = 3 [default = WINPC];
  if (cached_has_bits & 0x00000008u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_resourcetype(), target);
  }

  // optional string resourceName = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_resourcename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.AuthenticationReq)
  return target;
}

size_t AuthenticationReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.AuthenticationReq)
  size_t total_size = 0;

  // required .core.Jid jid = 1;
  if (has_jid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *jid_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string password = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional string resourceName = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resourcename());
    }

  }
  // optional .core.AuthenticationReq.ResourceType resourceType = 3 [default = WINPC];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_resourcetype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthenticationReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthenticationReq*>(
      &from));
}

void AuthenticationReq::MergeFrom(const AuthenticationReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.AuthenticationReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      password_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.password_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      resourcename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.resourcename_);
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_jid()->::core::Jid::MergeFrom(from._internal_jid());
    }
    if (cached_has_bits & 0x00000008u) {
      resourcetype_ = from.resourcetype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AuthenticationReq::CopyFrom(const AuthenticationReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.AuthenticationReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  if (has_jid()) {
    if (!this->jid_->IsInitialized()) return false;
  }
  return true;
}

void AuthenticationReq::InternalSwap(AuthenticationReq* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  password_.Swap(&other->password_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  resourcename_.Swap(&other->resourcename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(jid_, other->jid_);
  swap(resourcetype_, other->resourcetype_);
}

std::string AuthenticationReq::GetTypeName() const {
  return "core.AuthenticationReq";
}


// ===================================================================

void Response::InitAsDefaultInstance() {
}
class Response::_Internal {
 public:
  using HasBits = decltype(std::declval<Response>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cause(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Response::Response()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cause_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cause()) {
    cause_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cause_);
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:core.Response)
}

void Response::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Response_core_2eproto.base);
  cause_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_ = 0;
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:core.Response)
  SharedDtor();
}

void Response::SharedDtor() {
  cause_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Response& Response::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Response_core_2eproto.base);
  return *internal_default_instance();
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:core.Response)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    cause_.ClearNonDefaultToEmptyNoArena();
  }
  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cause = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_cause(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Response::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.Response)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 status = 1;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  // optional string cause = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cause(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.Response)
  size_t total_size = 0;

  // required int32 status = 1;
  if (has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_status());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string cause = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cause());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Response*>(
      &from));
}

void Response::MergeFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      cause_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.cause_);
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cause_.Swap(&other->cause_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(status_, other->status_);
}

std::string Response::GetTypeName() const {
  return "core.Response";
}


// ===================================================================

void AuthenticationResp::InitAsDefaultInstance() {
  ::core::_AuthenticationResp_default_instance_._instance.get_mutable()->resp_ = const_cast< ::core::Response*>(
      ::core::Response::internal_default_instance());
  ::core::_AuthenticationResp_default_instance_._instance.get_mutable()->fulljid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class AuthenticationResp::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticationResp>()._has_bits_);
  static const ::core::Response& resp(const AuthenticationResp* msg);
  static void set_has_resp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::core::Jid& fulljid(const AuthenticationResp* msg);
  static void set_has_fulljid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::core::Response&
AuthenticationResp::_Internal::resp(const AuthenticationResp* msg) {
  return *msg->resp_;
}
const ::core::Jid&
AuthenticationResp::_Internal::fulljid(const AuthenticationResp* msg) {
  return *msg->fulljid_;
}
AuthenticationResp::AuthenticationResp()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.AuthenticationResp)
}
AuthenticationResp::AuthenticationResp(const AuthenticationResp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_resp()) {
    resp_ = new ::core::Response(*from.resp_);
  } else {
    resp_ = nullptr;
  }
  if (from._internal_has_fulljid()) {
    fulljid_ = new ::core::Jid(*from.fulljid_);
  } else {
    fulljid_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:core.AuthenticationResp)
}

void AuthenticationResp::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AuthenticationResp_core_2eproto.base);
  ::memset(&resp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fulljid_) -
      reinterpret_cast<char*>(&resp_)) + sizeof(fulljid_));
}

AuthenticationResp::~AuthenticationResp() {
  // @@protoc_insertion_point(destructor:core.AuthenticationResp)
  SharedDtor();
}

void AuthenticationResp::SharedDtor() {
  if (this != internal_default_instance()) delete resp_;
  if (this != internal_default_instance()) delete fulljid_;
}

void AuthenticationResp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AuthenticationResp& AuthenticationResp::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AuthenticationResp_core_2eproto.base);
  return *internal_default_instance();
}


void AuthenticationResp::Clear() {
// @@protoc_insertion_point(message_clear_start:core.AuthenticationResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(resp_ != nullptr);
      resp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fulljid_ != nullptr);
      fulljid_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* AuthenticationResp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Response resp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_resp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .core.Jid fullJid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fulljid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AuthenticationResp::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.AuthenticationResp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Response resp = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::resp(this), target, stream);
  }

  // optional .core.Jid fullJid = 3;
  if (cached_has_bits & 0x00000002u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::fulljid(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.AuthenticationResp)
  return target;
}

size_t AuthenticationResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.AuthenticationResp)
  size_t total_size = 0;

  // required .core.Response resp = 1;
  if (has_resp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resp_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .core.Jid fullJid = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fulljid_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthenticationResp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthenticationResp*>(
      &from));
}

void AuthenticationResp::MergeFrom(const AuthenticationResp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.AuthenticationResp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_resp()->::core::Response::MergeFrom(from._internal_resp());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fulljid()->::core::Jid::MergeFrom(from._internal_fulljid());
    }
  }
}

void AuthenticationResp::CopyFrom(const AuthenticationResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.AuthenticationResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_resp()) {
    if (!this->resp_->IsInitialized()) return false;
  }
  if (has_fulljid()) {
    if (!this->fulljid_->IsInitialized()) return false;
  }
  return true;
}

void AuthenticationResp::InternalSwap(AuthenticationResp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(resp_, other->resp_);
  swap(fulljid_, other->fulljid_);
}

std::string AuthenticationResp::GetTypeName() const {
  return "core.AuthenticationResp";
}


// ===================================================================

void Heartbeat::InitAsDefaultInstance() {
}
class Heartbeat::_Internal {
 public:
  using HasBits = decltype(std::declval<Heartbeat>()._has_bits_);
};

Heartbeat::Heartbeat()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.Heartbeat)
}
Heartbeat::Heartbeat(const Heartbeat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:core.Heartbeat)
}

void Heartbeat::SharedCtor() {
}

Heartbeat::~Heartbeat() {
  // @@protoc_insertion_point(destructor:core.Heartbeat)
  SharedDtor();
}

void Heartbeat::SharedDtor() {
}

void Heartbeat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Heartbeat& Heartbeat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Heartbeat_core_2eproto.base);
  return *internal_default_instance();
}


void Heartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:core.Heartbeat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Heartbeat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Heartbeat::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.Heartbeat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.Heartbeat)
  return target;
}

size_t Heartbeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.Heartbeat)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Heartbeat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Heartbeat*>(
      &from));
}

void Heartbeat::MergeFrom(const Heartbeat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.Heartbeat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Heartbeat::CopyFrom(const Heartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.Heartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Heartbeat::IsInitialized() const {
  return true;
}

void Heartbeat::InternalSwap(Heartbeat* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

std::string Heartbeat::GetTypeName() const {
  return "core.Heartbeat";
}


// ===================================================================

void HeartbeatAck::InitAsDefaultInstance() {
  ::core::_HeartbeatAck_default_instance_._instance.get_mutable()->fromjid_ = const_cast< ::core::Jid*>(
      ::core::Jid::internal_default_instance());
}
class HeartbeatAck::_Internal {
 public:
  using HasBits = decltype(std::declval<HeartbeatAck>()._has_bits_);
  static const ::core::Jid& fromjid(const HeartbeatAck* msg);
  static void set_has_fromjid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::core::Jid&
HeartbeatAck::_Internal::fromjid(const HeartbeatAck* msg) {
  return *msg->fromjid_;
}
HeartbeatAck::HeartbeatAck()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:core.HeartbeatAck)
}
HeartbeatAck::HeartbeatAck(const HeartbeatAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_fromjid()) {
    fromjid_ = new ::core::Jid(*from.fromjid_);
  } else {
    fromjid_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:core.HeartbeatAck)
}

void HeartbeatAck::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_HeartbeatAck_core_2eproto.base);
  fromjid_ = nullptr;
}

HeartbeatAck::~HeartbeatAck() {
  // @@protoc_insertion_point(destructor:core.HeartbeatAck)
  SharedDtor();
}

void HeartbeatAck::SharedDtor() {
  if (this != internal_default_instance()) delete fromjid_;
}

void HeartbeatAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HeartbeatAck& HeartbeatAck::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HeartbeatAck_core_2eproto.base);
  return *internal_default_instance();
}


void HeartbeatAck::Clear() {
// @@protoc_insertion_point(message_clear_start:core.HeartbeatAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(fromjid_ != nullptr);
    fromjid_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* HeartbeatAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .core.Jid fromJid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fromjid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HeartbeatAck::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:core.HeartbeatAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .core.Jid fromJid = 1;
  if (cached_has_bits & 0x00000001u) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::fromjid(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:core.HeartbeatAck)
  return target;
}

size_t HeartbeatAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:core.HeartbeatAck)
  size_t total_size = 0;

  // required .core.Jid fromJid = 1;
  if (has_fromjid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fromjid_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const HeartbeatAck*>(
      &from));
}

void HeartbeatAck::MergeFrom(const HeartbeatAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:core.HeartbeatAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fromjid()) {
    _internal_mutable_fromjid()->::core::Jid::MergeFrom(from._internal_fromjid());
  }
}

void HeartbeatAck::CopyFrom(const HeartbeatAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:core.HeartbeatAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_fromjid()) {
    if (!this->fromjid_->IsInitialized()) return false;
  }
  return true;
}

void HeartbeatAck::InternalSwap(HeartbeatAck* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(fromjid_, other->fromjid_);
}

std::string HeartbeatAck::GetTypeName() const {
  return "core.HeartbeatAck";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace core
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::core::Jid* Arena::CreateMaybeMessage< ::core::Jid >(Arena* arena) {
  return Arena::CreateInternal< ::core::Jid >(arena);
}
template<> PROTOBUF_NOINLINE ::core::AuthenticationReq* Arena::CreateMaybeMessage< ::core::AuthenticationReq >(Arena* arena) {
  return Arena::CreateInternal< ::core::AuthenticationReq >(arena);
}
template<> PROTOBUF_NOINLINE ::core::Response* Arena::CreateMaybeMessage< ::core::Response >(Arena* arena) {
  return Arena::CreateInternal< ::core::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::core::AuthenticationResp* Arena::CreateMaybeMessage< ::core::AuthenticationResp >(Arena* arena) {
  return Arena::CreateInternal< ::core::AuthenticationResp >(arena);
}
template<> PROTOBUF_NOINLINE ::core::Heartbeat* Arena::CreateMaybeMessage< ::core::Heartbeat >(Arena* arena) {
  return Arena::CreateInternal< ::core::Heartbeat >(arena);
}
template<> PROTOBUF_NOINLINE ::core::HeartbeatAck* Arena::CreateMaybeMessage< ::core::HeartbeatAck >(Arena* arena) {
  return Arena::CreateInternal< ::core::HeartbeatAck >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
